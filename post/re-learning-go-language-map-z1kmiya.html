<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>重学Go语言 | Map - 林庭晚阖</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="林庭晚阖"><meta name="msapplication-TileImage" content="/img/kafka.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="林庭晚阖"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="重温Map基础"><meta property="og:type" content="blog"><meta property="og:title" content="重学Go语言 | Map"><meta property="og:url" content="https://luommy.github.io/post/re-learning-go-language-map-z1kmiya.html"><meta property="og:site_name" content="林庭晚阖"><meta property="og:description" content="重温Map基础"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202312061138052.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202312061138650.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202312061138827.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202312061749546.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202312061749191.png"><meta property="article:published_time" content="2023-12-05T07:35:49.000Z"><meta property="article:modified_time" content="2023-12-06T09:48:36.000Z"><meta property="article:author" content="luommy"><meta property="article:tag" content="golang"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202312061138052.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://luommy.github.io/post/re-learning-go-language-map-z1kmiya.html"},"headline":"重学Go语言 | Map","image":["https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202312061138052.png","https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202312061138650.png","https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202312061138827.png","https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202312061749546.png","https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202312061749191.png"],"datePublished":"2023-12-05T07:35:49.000Z","dateModified":"2023-12-06T09:48:36.000Z","author":{"@type":"Person","name":"luommy"},"publisher":{"@type":"Organization","name":"林庭晚阖","logo":{"@type":"ImageObject","url":"https://luommy.github.io/img/logo.svg"}},"description":"重温Map基础"}</script><link rel="canonical" href="https://luommy.github.io/post/re-learning-go-language-map-z1kmiya.html"><link rel="icon" href="/img/kafka.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/vs.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?ecf13ffee9f4083d9a74b337b541f90b";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script>
  <link rel="stylesheet" href="/custom/custom.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="林庭晚阖" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">文章</a><a class="navbar-item" href="/tags/timeline">心情</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/links.html">友链</a><a class="navbar-item" href="/guestbook.html">留言</a><a class="navbar-item" href="/about.html">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="发邮件" href="mailto:jdonglecool@163.com"><i class="fab fa-regular fa-envelope"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com/luommy"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-12-05T07:35:49.000Z" title="12/5/2023, 7:35:49 AM">2023-12-05</time>发表</span><span class="level-item"><time dateTime="2023-12-06T09:48:36.000Z" title="12/6/2023, 9:48:36 AM">2023-12-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Golang/">Golang</a><span> / </span><a class="link-muted" href="/categories/Golang/%E9%87%8D%E5%AD%A6%E7%B3%BB%E5%88%97/">重学系列</a></span><span class="level-item">1 小时读完 (大约8027个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">重学Go语言 | Map</h1><div class="content"><h1 id="重学Go语言-Map"><a href="#重学Go语言-Map" class="headerlink" title="重学Go语言 | Map"></a>重学Go语言 | Map</h1><blockquote>
<p>Go重学系列不追求底层和深度，只求重温下没有使用过或者使用过的一些操作，要注意的细节，以及彻底掌握的一种前提思路。后续讲重学与底层部分练习在一起进行双链操作。</p>
<p>重学篇在自己重温Go的同时，也希望努力做最好的初学教程</p>
<p>本篇思路：什么是map、map的格式与数据类型限制、map的特征、如何创建与初始化等</p>
</blockquote>
<h1 id="Map简述"><a href="#Map简述" class="headerlink" title="Map简述"></a>Map简述</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Go语言中的map(映射、字典、哈希表)是一种内置的数据结构，它是一个无序的key-value对的集合，</span><br><span class="line">比如以身份证号作为唯一键来标识一个人的信息。Go语言中并没有提供一个set类型，</span><br><span class="line">但是map中的key也是不相同的，可以用map实现类似set的功能。</span><br></pre></td></tr></table></figure>

<p>从表面上看map大致是这样的：</p>
<p>​<img src="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202312061138052.png" alt="image">​</p>
<p>​<img src="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202312061138650.png">​</p>
<p>从底层看：</p>
<p>​<code>map</code>​是一个无序的键值对(<code>key-value</code>​)集合，其底层数据结构是一个哈希表，通过<span style="font-weight: bold;" data-type="strong">哈希函数</span>，将<code>key</code>​转换为对哈希表中的索引，将<code>value</code>​存储到索引对应的位置，在<code>map</code>​中查找、删除、查找value的时间复杂度<code>O(1)</code>​。</p>
<p>​<img src="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202312061138827.png" alt="image">​</p>
<h1 id="map格式与数据类型限制"><a href="#map格式与数据类型限制" class="headerlink" title="map格式与数据类型限制"></a>map格式与数据类型限制</h1><p><span style="font-weight: bold;" data-type="strong">关键点：key数据类型限制</span></p>
<p>map的value可以是Go支持的任意数据类型，而key则所有限制：</p>
<blockquote>
<p><span style="font-weight: bold;" data-type="strong">key的数据类型必须是可以使用</span>​ <span style="font-weight: bold;" data-type="strong"><code>=</code></span> ​<span style="font-weight: bold;" data-type="strong">和</span>​ <span style="font-weight: bold;" data-type="strong"><code>!=</code></span> ​<span style="font-weight: bold;" data-type="strong">进行比较</span></p>
<p><u>所以，key不能是函数、切片、map，因此这些数据类型不能进行比较，另外，而数组和结构体则可以作为map的key，不过，如果数组的元素包含函数、切片、map，则数组不能作为map的key，结构体的字段如果有以上三者，也同样不能作为map的key。</u></p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Test <span class="keyword">struct</span> &#123;</span><br><span class="line"> ID   <span class="type">string</span></span><br><span class="line"> Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//正确</span></span><br><span class="line">m := <span class="keyword">map</span>[Test]<span class="type">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Test <span class="keyword">struct</span> &#123;</span><br><span class="line"> ID     <span class="type">string</span></span><br><span class="line"> Name   <span class="type">string</span></span><br><span class="line">  scores []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//报错</span></span><br><span class="line">m := <span class="keyword">map</span>[Test]<span class="type">int</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><span style="font-weight: bold;" data-type="strong">key的值必须是唯一，同一个map中不能相同的两个key</span></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line"> <span class="string">&quot;name&quot;</span>:<span class="string">&quot;小明&quot;</span>,</span><br><span class="line"> <span class="string">&quot;age&quot;</span>:<span class="string">&quot;24&quot;</span>,</span><br><span class="line"> <span class="string">&quot;name&quot;</span>:<span class="string">&quot;小墨&quot;</span><span class="comment">//报错，不能有相同的key</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在Go语言中，用 map[KeyType]ValueType 表示一个map，</span></span><br><span class="line"><span class="comment">//其中，KeyType 表示 key 的数据类型，ValueType 表示 value 的数据类型：</span></span><br><span class="line"><span class="keyword">map</span>[keyType]valueType</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ※ 重点 ※  </span></span><br><span class="line"><span class="comment">// 在一个 map 里所有的键都是唯一的，而且必须是支持 == 和 != 操作符的类型，</span></span><br><span class="line"><span class="comment">// 切片、函数以及包含切片的结构类型这些类型由于具有引用语义，不能作为映射的键，</span></span><br><span class="line"><span class="comment">// 使用这些类型会造成编译错误：</span></span><br><span class="line">dict := <span class="keyword">map</span>[ []<span class="type">string</span> ]<span class="type">int</span>&#123;&#125; <span class="comment">//err, invalid map key type []string</span></span><br></pre></td></tr></table></figure>

<p>—✩ ✰ ✪ ✫—</p>
<p>map值可以是任意类型，没有限制。map里所有键的数据类型必须是相同的，值也必须如此，但键和值的数据类型可以不相同。</p>
<p><span style="font-weight: bold;" data-type="strong">注意：</span>​<u>map是无序的，我们无法决定它的返回顺序，所以，每次打印结果的顺序有可能不同。</u></p>
<p>–&gt;这个地方就有深度了，为什么map遍历是无序的？ Java中的set也是如此吗？为什么？原理是否一样？</p>
<h1 id="map的特征"><a href="#map的特征" class="headerlink" title="map的特征"></a>map的特征</h1><p>推导总结：</p>
<ul>
<li>map是无序的</li>
<li>map的key是唯一的</li>
<li>map是引用数据类型，因此在使用前必须初始化</li>
<li>函数，切片，map等数据类型不能作为map的key。key必须是可比较的类型，可以是结构体和数组，不能是切片、函数、map，且结构体和数组中也不能包含以上三者中的任何</li>
</ul>
<h1 id="创建及初始化Map"><a href="#创建及初始化Map" class="headerlink" title="创建及初始化Map"></a>创建及初始化Map</h1><p>很多教程都是直接告诉你如何初始化，可能只教一种实现方式，不教所以然，这样很片面</p>
<h2 id="未经初始化"><a href="#未经初始化" class="headerlink" title="未经初始化"></a>未经初始化</h2><p>由于<code>map</code>​是引用数据类型，其底层引用一个哈希表，因此未经初始化(即未分配到内存空间)的<code>map</code>​无法直接使用：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line"></span><br><span class="line">m[<span class="string">&quot;a&quot;</span>] = <span class="number">1</span> </span><br><span class="line"><span class="comment">//未初始化，报错</span></span><br></pre></td></tr></table></figure>

<h2 id="初始化方式"><a href="#初始化方式" class="headerlink" title="初始化方式"></a>初始化方式</h2><p>初始化map有两种方式：</p>
<ul>
<li>使用make函数</li>
<li>字面量初始化</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://www.yuque.com/aceld/golang/xu2t51">刘丹冰：New与Make</a></p>
<p>理论上New也是可行的，但是十分不推荐</p>
<h3 id="make函数"><a href="#make函数" class="headerlink" title="make函数"></a>make函数</h3><p>内置函数make可以为<code>map</code>​类型的变量分配内存：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">m[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;test&quot;</span></span><br><span class="line">m[<span class="string">&quot;age&quot;</span>] = <span class="string">&quot;12&quot;</span></span><br></pre></td></tr></table></figure>

<p>此外还可以指定容量初始化：</p>
<p>这种方式有好处也有劣势，好处是省去了频繁地扩容，坏处是如果一次性建立很大的容量但实际上并不需要会造成资源浪费</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>, <span class="number">10</span>) 	<span class="comment">//第2个参数指定容量“10”</span></span><br><span class="line">fmt.Println(m)                	<span class="comment">//map[]</span></span><br></pre></td></tr></table></figure>

<p>这种方法指定了map的初始创建容量。与slice类似，后期在使用过程中，map可以自动扩容。</p>
<p>只不过map更方便一些，不用借助类似append的函数，直接赋值即可。如，m[17] &#x3D; “Nami”。赋值过程中，key如果与已有map中key重复，会将原有map中key对应的value覆盖。但是！对于map而言，可以使用len()函数，<span style="font-weight: bold;" data-type="strong"><em><u>但不能使用 cap() 函数。</u></span></em></p>
<p>map是一种可以动态增长的数据结构，但由于其底层实现的复杂性，能直接获取其容量，只能使用<code>len()</code>​函数来获取其元素数量。</p>
<h3 id="字面量初始化"><a href="#字面量初始化" class="headerlink" title="字面量初始化"></a>字面量初始化</h3><ol>
<li>初始化同时赋值</li>
</ol>
<p>通过字面量初始化<code>map</code>​时，可以给<code>map</code>​中的<code>key</code>​和<code>value</code>​赋初始值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这样直接指定初值，要保证key不重复。</span></span><br><span class="line"><span class="comment">// 注意！这是常用的方式，使用“：”自动推导的方式</span></span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line"> <span class="string">&quot;name&quot;</span>:<span class="string">&quot;test&quot;</span>,</span><br><span class="line"> <span class="string">&quot;age&quot;</span>:<span class="string">&quot;12&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当然了，还有一种不常用的方式：</span></span><br><span class="line"><span class="comment">// 定义的同时完成初始化，但有一说一这种方式太不简洁了</span></span><br><span class="line"><span class="keyword">var</span> m1 <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span> = <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>&#123;<span class="number">1</span>: <span class="string">&quot;Luffy&quot;</span>, <span class="number">2</span>: <span class="string">&quot;Sanji&quot;</span>&#125;</span><br><span class="line">    fmt.Println(m1) <span class="comment">//map[1:Luffy 2:Sanji]</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>只初始化，不赋值</li>
</ol>
<p><span style="font-weight: bold;" data-type="strong">常用：</span> </p>
<p>如果不想给map初始化数据，也可以声明一个空的map类型，自动分配了内存：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的`m`是一个字符串键和字符串值类型的map，但你也可以根据需要更改其键和值类型。</span></span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，空的map已经初始化好了，只是没有存入值而已，而直接声明一个map变量时，该map变量为nil，这两者不一样</p>
</blockquote>
<p><span style="font-weight: bold;" data-type="strong">不常用：</span> </p>
<p>声明一个未初始化的map的方式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br></pre></td></tr></table></figure>

<p>这里的<code>m</code>​是一个字符串键和字符串值类型的map变量，但它没有被初始化，因此不能直接使用，如果你尝试在其上执行读或写操作，会触发panic错误。要使用未初始化的map，还需要使用make函数对其进行初始化，如下所示：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var这种方式也不常用，因为还要再写这一行完成内存分配才能使用</span></span><br><span class="line">m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br></pre></td></tr></table></figure>

<p>这样，你的map就可以安全地使用了。</p>
<h3 id="非要用new初始化"><a href="#非要用new初始化" class="headerlink" title="非要用new初始化"></a>非要用new初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 使用 new 创建 map</span></span><br><span class="line">    myMap := <span class="built_in">new</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 初始化 map</span></span><br><span class="line">    *myMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 向 map 中添加键值对</span></span><br><span class="line">    (*myMap)[<span class="string">&quot;apple&quot;</span>] = <span class="number">1</span></span><br><span class="line">    (*myMap)[<span class="string">&quot;banana&quot;</span>] = <span class="number">2</span></span><br><span class="line">    (*myMap)[<span class="string">&quot;orange&quot;</span>] = <span class="number">3</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 遍历 map 并打印键值对</span></span><br><span class="line">    <span class="keyword">for</span> key, value := <span class="keyword">range</span> *myMap &#123;</span><br><span class="line">        fmt.Println(key, <span class="string">&quot;:&quot;</span>, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>‍</p>
<h1 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h1><h2 id="赋值与访问"><a href="#赋值与访问" class="headerlink" title="赋值与访问"></a>赋值与访问</h2><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>赋值上来说：有直接初始化的同时直接赋值，也有先初始化，再赋值这两种</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">m1 := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>&#123;<span class="number">1</span>: <span class="string">&quot;Luffy&quot;</span>, <span class="number">2</span>: <span class="string">&quot;Sanji&quot;</span>&#125;</span><br><span class="line">m1[<span class="number">1</span>] = <span class="string">&quot;Nami&quot;</span>   <span class="comment">//修改</span></span><br><span class="line">m1[<span class="number">3</span>] = <span class="string">&quot;Zoro&quot;</span>  <span class="comment">//追加， go底层会自动为map分配空间</span></span><br><span class="line">fmt.Println(m1) <span class="comment">//map[1:Nami 2:Sanji 3:Zoro]</span></span><br><span class="line"></span><br><span class="line">m2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>, <span class="number">10</span>) 	<span class="comment">//创建map，指定容量</span></span><br><span class="line">m2[<span class="number">0</span>] = <span class="string">&quot;aaa&quot;</span></span><br><span class="line">m2[<span class="number">1</span>] = <span class="string">&quot;bbb&quot;</span></span><br><span class="line">fmt.Println(m2)           		<span class="comment">//map[0:aaa 1:bbb]</span></span><br><span class="line">fmt.Println(m2[<span class="number">0</span>], m2[<span class="number">1</span>]) 		<span class="comment">//aaa bbb</span></span><br></pre></td></tr></table></figure>

<h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p>通过key，可以访问map变量中的value：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rank : = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line">  <span class="string">&quot;PHP&quot;</span>:<span class="number">90</span>,</span><br><span class="line">  <span class="string">&quot;Go&quot;</span>:<span class="number">99</span></span><br><span class="line">  <span class="string">&quot;Java&quot;</span>:<span class="number">95</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(rank[<span class="string">&quot;PHP&quot;</span>])</span><br></pre></td></tr></table></figure>

<p><em>如果对应的key不存在，则会返回对应value数据类型的空值，比如value为string，则返回空字符串：</em></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为value为int</span></span><br><span class="line">fmt.Println(rank[<span class="string">&quot;Python&quot;</span>]) </span><br><span class="line"><span class="comment">// 输出：0</span></span><br><span class="line"></span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;小张&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//由于value为string类型</span></span><br><span class="line">fmt.Println(m[<span class="string">&quot;age&quot;</span>]) </span><br><span class="line"><span class="comment">//输出空字符串</span></span><br></pre></td></tr></table></figure>

<h2 id="判断key是否存在"><a href="#判断key是否存在" class="headerlink" title="判断key是否存在"></a>判断key是否存在</h2><p>如果我们想在通过key访问map之前就确定对应的key是否存在，有另外一种写法：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v, ok := m[k]</span><br></pre></td></tr></table></figure>

<p>上面的表达式中，有第二个返回值<code>ok</code>​，该值为boolean类型，当key存在时，<code>ok</code>​的值为true，<code>v</code>​为对应的<code>value</code>​；否则为<code>ok</code>​为<code>false</code>​,<code>v</code>​为空值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">v,ok := rank[k]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line"> fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二，这种更常见</span></span><br><span class="line"><span class="keyword">if</span> v,ok := rank[k];ok&#123;</span><br><span class="line">  fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有时候可能需要知道对应的元素是否真的是在map之中。<br>可以使用下标语法判断某个key是否存在。<br>map的下标语法将产生两个值，其中第二个是一个布尔值，用于报告元素是否真的存在。<br>如果key存在，第一个返回值返回value的值。第二个返回值为 true。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一：</span></span><br><span class="line">v,ok := rank[k]</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line"> fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：这种可能更常见</span></span><br><span class="line"><span class="keyword">if</span> v,ok := rank[k];ok&#123;</span><br><span class="line">  fmt.Println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>使用<code>for-range</code>​语句可以遍历<code>map</code>​，获得<code>map</code>​的<code>key</code>​和<code>value</code>​：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>:<span class="string">&quot;xiaoming&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>:<span class="string">&quot;18岁&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> k,v := <span class="keyword">range</span> m&#123;</span><br><span class="line">  fmt.Println(k,v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>Map的迭代顺序是不确定的，并且不同的[哈希函数]实现可能导致不同的遍历顺序。<br>在实践中，遍历的顺序是随机的，每一次遍历的顺序都不相同。<br>这是故意的，每次都使用随机的遍历顺序可以强制要求程序不会依赖具体的哈希函数实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">m1 := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>&#123;<span class="number">1</span>: <span class="string">&quot;Luffy&quot;</span>, <span class="number">2</span>: <span class="string">&quot;Sanji&quot;</span>&#125;</span><br><span class="line"><span class="comment">//遍历1，第一个返回值是key，第二个返回值是value</span></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m1 &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d ----&gt; %s\n&quot;</span>, k, v)</span><br><span class="line"><span class="comment">//1 ----&gt; Luffy</span></span><br><span class="line"><span class="comment">//2 ----&gt; yoyo</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历2，第一个返回值是key，第二个返回值是value（可省略）</span></span><br><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> m1 &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d ----&gt; %s\n&quot;</span>, k, m1[k])</span><br><span class="line"><span class="comment">//1 ----&gt; Luffy</span></span><br><span class="line"><span class="comment">//2 ----&gt; Sanji</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>要删除map的value，可以使用Go内置的<code>delete</code>​函数，该函数格式如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">delete</span><span class="params">(m <span class="keyword">map</span>[KeyType]ValueType, key Type)</span></span></span><br></pre></td></tr></table></figure>

<p>该函数的第一个参数是我们要操作的map类型的变量，第二个参数表示要删除哪个key：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line">  <span class="string">&quot;a&quot;</span>:<span class="number">1</span>,</span><br><span class="line">  <span class="string">&quot;b&quot;</span>:<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(m)</span><br><span class="line"><span class="built_in">delete</span>(m,<span class="string">&quot;a&quot;</span>)</span><br><span class="line">fmt.Println(m)</span><br></pre></td></tr></table></figure>

<p>使用delete()函数，指定key值可以方便的删除map中的k-v映射。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">m1 := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>&#123;<span class="number">1</span>: <span class="string">&quot;Luffy&quot;</span>, <span class="number">2</span>: <span class="string">&quot;Sanji&quot;</span>, <span class="number">3</span>: <span class="string">&quot;Zoro&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m1 &#123;	<span class="comment">//遍历，第一个返回值是key，第二个返回值是value</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d ----&gt; %s\n&quot;</span>, k, v)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//1 ----&gt; Sanji</span></span><br><span class="line"><span class="comment">//2 ----&gt; Sanji</span></span><br><span class="line"><span class="comment">//3 ----&gt; Zoro</span></span><br><span class="line"><span class="built_in">delete</span>(m1, <span class="number">2</span>) 		<span class="comment">//删除key值为2的map</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m1 &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d ----&gt; %s\n&quot;</span>, k, v)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//1 ----&gt; Luffy</span></span><br><span class="line"><span class="comment">//3 ----&gt; Zoro</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用delete删除一个不存在的key</span></span><br><span class="line"><span class="built_in">delete</span>(m1, <span class="number">5</span>) 		<span class="comment">//删除key值为5的map</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m1 &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%d ----&gt; %s\n&quot;</span>, k, v)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//1 ----&gt; Luffy</span></span><br><span class="line"><span class="comment">//3 ----&gt; Zoro</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Map输出结果依然是原来的样子，且不会有任何错误提示。</p>
<p>delete()操作是安全的，即使元素不在map中也没有关系；如果查找删除失败将返回value类型对应的零值。</p>
<h2 id="获取长度"><a href="#获取长度" class="headerlink" title="获取长度"></a>获取长度</h2><p>map中无法获取容量，也就是无法使用cap函数，它的容量是动态变化的，内部是通过哈希表实现的，底层实现与数组、切片不同；同时，他们的扩容机制【slice与map】有何不同？</p>
<p>要获取map的长度，同样是用内置的<code>len</code>​函数：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line"> <span class="string">&quot;id&quot;</span>:   <span class="string">&quot;0001&quot;</span>,</span><br><span class="line"> <span class="string">&quot;name&quot;</span>: <span class="string">&quot;小张&quot;</span>,</span><br><span class="line"> <span class="string">&quot;age&quot;</span>:  <span class="string">&quot;18岁&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="built_in">len</span>(user)) </span><br><span class="line"><span class="comment">//输出：3</span></span><br></pre></td></tr></table></figure>

<h2 id="Map嵌套"><a href="#Map嵌套" class="headerlink" title="Map嵌套"></a>Map嵌套</h2><p>由于<code>map</code>​的<code>value</code>​并没有数据类型的限制，所以<code>value</code>​也可以是另一个<code>map</code>​类型：</p>
<blockquote>
<p>理论上map嵌套map可以一直嵌套下去，但一般不会这么做的。很丑！</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mm := <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>&#123;</span><br><span class="line">	<span class="string">&quot;a&quot;</span>: &#123;<span class="number">1</span>: <span class="string">&quot;test1&quot;</span>&#125;,</span><br><span class="line">	<span class="string">&quot;b&quot;</span>: &#123;<span class="number">2</span>: <span class="string">&quot;test2&quot;</span>&#125;,</span><br><span class="line">	<span class="string">&quot;c&quot;</span>: &#123;<span class="number">2</span>: <span class="string">&quot;test3&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(mm)</span><br></pre></td></tr></table></figure>

<h2 id="Map做函数参数"><a href="#Map做函数参数" class="headerlink" title="Map做函数参数"></a>Map做函数参数</h2><p>与slice 相似，在函数间传递映射并不会制造出该映射的一个副本，不是[值传递]，而是引用传递</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DeleteMap</span><span class="params">(m <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>, key <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="built_in">delete</span>(m, key) <span class="comment">//删除key值为2的map</span></span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;len(m)=%d, %d ----&gt; %s\n&quot;</span>, <span class="built_in">len</span>(m), k, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//len(m)=2, 1 ----&gt; Luffy</span></span><br><span class="line"><span class="comment">//len(m)=2, 3 ----&gt; Zoro</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>&#123;<span class="number">1</span>: <span class="string">&quot;Luffy&quot;</span>, <span class="number">2</span>: <span class="string">&quot;Sanji&quot;</span>, <span class="number">3</span>: <span class="string">&quot;Zoro&quot;</span>&#125;</span><br><span class="line">    DeleteMap(m, <span class="number">2</span>) 	<span class="comment">//删除key值为2的map</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;len(m)=%d, %d ----&gt; %s\n&quot;</span>, <span class="built_in">len</span>(m), k, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//len(m)=2, 1 ----&gt; Luffy</span></span><br><span class="line"><span class="comment">//len(m)=2, 3 ----&gt; Zoro</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Map做函数返回值"><a href="#Map做函数返回值" class="headerlink" title="Map做函数返回值"></a>Map做函数返回值</h2><p>返回的依然是引用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span> &#123;</span><br><span class="line"><span class="comment">//  m1 := map[int]string&#123;1: &quot;Luffy&quot;, 2: &quot;Sanji&quot;, 3: &quot;Zoro&quot;&#125;</span></span><br><span class="line">    m1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>, <span class="number">1</span>)     <span class="comment">// 创建一个初创容量为1的map</span></span><br><span class="line">    m1[<span class="number">1</span>] = <span class="string">&quot;Luffy&quot;</span></span><br><span class="line">    m1[<span class="number">2</span>] = <span class="string">&quot;Sanji&quot;</span>                   <span class="comment">// 自动扩容</span></span><br><span class="line">    m1[<span class="number">67</span>] = <span class="string">&quot;Zoro&quot;</span></span><br><span class="line">    m1[<span class="number">2</span>] = <span class="string">&quot;Nami&quot;</span>                	  <span class="comment">// 覆盖 key值为2 的map</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;m1 = &quot;</span>, m1)</span><br><span class="line">	<span class="keyword">return</span> m1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m2 := test()                  	  <span class="comment">// 返回值 —— 传引用</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;m2 = &quot;</span>, m2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m1 =  map[1:Luffy 2:Nami 67:Zoro]</span><br><span class="line">m2 =  map[2:Nami 67:Zoro 1:Luffy]</span><br></pre></td></tr></table></figure>

<h2 id="Map的排序"><a href="#Map的排序" class="headerlink" title="Map的排序"></a>Map的排序</h2><p>​<code>map</code>​是无序的，所以每次遍历<code>map</code>​输出的顺序都不一定相同</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line"> <span class="string">&quot;id&quot;</span>:   <span class="string">&quot;0001&quot;</span>,</span><br><span class="line"> <span class="string">&quot;name&quot;</span>: <span class="string">&quot;小张&quot;</span>,</span><br><span class="line"> <span class="string">&quot;age&quot;</span>:  <span class="string">&quot;18岁&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> user &#123;</span><br><span class="line"> fmt.Println(k, <span class="string">&quot;:&quot;</span>, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> user &#123;</span><br><span class="line"> fmt.Println(k, <span class="string">&quot;:&quot;</span>,v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要有序地遍历一个map类型的变量，可以这么做：</p>
<p>利用切片将map中的key固定排序，这样就稳定了顺序</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">order := []<span class="type">string</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> k, _ := <span class="keyword">range</span> user &#123;</span><br><span class="line"> order = <span class="built_in">append</span>(order, k)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对user中的key进行升序排序</span></span><br><span class="line"><span class="comment">// sort.Strings(order)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> order &#123;</span><br><span class="line"> fmt.Println(user[v])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> order &#123;</span><br><span class="line"> fmt.Println(user[v])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Map之间无法比较，只能与nil比较"><a href="#Map之间无法比较，只能与nil比较" class="headerlink" title="Map之间无法比较，只能与nil比较"></a>Map之间无法比较，只能与nil比较</h2><p>​<code>map</code>​类型变量之间不能进行比较，<code>map</code>​只能与<code>nil</code>​进行比较：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span></span><br><span class="line"><span class="comment">//判断是否等于nil</span></span><br><span class="line"><span class="keyword">if</span> m == <span class="literal">nil</span>&#123;</span><br><span class="line"> fmt.Println(<span class="string">&quot;m hasn&#x27;t been initialized&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m1 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;小明&quot;</span>&#125;</span><br><span class="line">m2 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;小明&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//报错</span></span><br><span class="line"><span class="keyword">if</span> m1 == m2 &#123;</span><br><span class="line"> fmt.Println(<span class="string">&quot;相等&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个地方我看到有的教程说：“nil map 和空 map 是相等的，只是 nil map 不能添加元素。”这个map之间不能被比较何来相等一说？对此有疑问</p>
<h2 id="不能对Map的value进行取址操作"><a href="#不能对Map的value进行取址操作" class="headerlink" title="不能对Map的value进行取址操作"></a>不能对Map的value进行取址操作</h2><p>取址操作作用：</p>
<p>当对数组和切片进行取址操作时，我们可以实现参数传递、修改元素和实现数据结构等功能。以下是一些示例：</p>
<ol>
<li>参数传递：</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">modifyElement</span><span class="params">(arr *[3]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    (*arr)[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    array := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    modifyElement(&amp;array)</span><br><span class="line">    fmt.Println(array) <span class="comment">// 输出 [100 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，通过对数组元素取址，将数组作为指针传递给函数<code>modifyElement</code>​，在函数内部可以直接修改数组元素的值。</p>
<ol start="2">
<li>修改元素：</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    slice := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">    fmt.Println(slice) <span class="comment">// 输出 [1 2 3]</span></span><br><span class="line">    slicePtr := &amp;slice</span><br><span class="line">    (*slicePtr)[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">    fmt.Println(slice) <span class="comment">// 输出 [100 2 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，通过对切片元素取址，可以直接修改切片中的元素值。</p>
<ol start="3">
<li>实现数据结构：</li>
</ol>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">    Value <span class="type">int</span></span><br><span class="line">    Next  *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    node1 := Node&#123;Value: <span class="number">1</span>&#125;</span><br><span class="line">    node2 := Node&#123;Value: <span class="number">2</span>&#125;</span><br><span class="line">    node1.Next = &amp;node2</span><br><span class="line"></span><br><span class="line">    fmt.Println(node1.Value)   <span class="comment">// 输出 1</span></span><br><span class="line">    fmt.Println(node1.Next.Value)  <span class="comment">// 输出 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们通过对结构体中的指针字段进行取址操作，实现了链表数据结构。</p>
<p>这些示例展示了如何使用数组和切片的取址操作来实现参数传递、修改元素和实现数据结构，从而充分展示了取址操作的用处。</p>
<p>Go的数组和切片允许对元素进行取址操作，但不允许对map的元素进行取址操作：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对数组元素取址</span></span><br><span class="line">a := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(&amp;a[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">//对切片元素取址</span></span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">fmt.Println(&amp;s[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">//对map元素取址，错误</span></span><br><span class="line">m := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">  <span class="string">&quot;test&quot;</span>:<span class="string">&quot;test&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&amp;m[<span class="string">&quot;test&quot;</span>])</span><br></pre></td></tr></table></figure>

<p><u><em>为什么Go允许数组、切片进行取址操作，但要限制对map的元素取址呢？</em></u> </p>
<p>因为Go可以在添加新的键值对时更改键值对的内存位置。Go将在后台执行此操作，以将检索键值对的复杂性保持在恒定水平。因此，地址可能会变得无效，Go宁愿禁止访问一个可能无效的地址。</p>
<blockquote>
<p>对map不允许直接进行取址操作的主要原因是为了避免潜在的数据竞争和安全问题。</p>
<p>在Go语言中，map是通过哈希表实现的，它的内部结构相对复杂。当我们对map进行取址操作时，实际上是获取了一个指向底层哈希表的指针。这样一来，如果在获取指针后对map进行了添加、删除或重新分配内存等操作，会导致指针指向的地址发生变化，从而可能使之前获取到的指针失效或指向无效的内存区域。这就会造成潜在的数据不一致性和安全隐患。</p>
<p>为了避免这种情况，Go语言禁止对map进行取址操作，并且在对map进行增删改等操作时，可能会触发内部的扩容和重新散列等操作，从而导致map的底层数据结构发生变化。如果允许对map进行取址操作，那么在并发访问的情况下，就可能引发竞态条件，导致数据不一致或安全问题。</p>
<p>相反，对数组和切片进行取址操作是允许的。这是因为数组和切片的内部结构相对简单，取址操作不会引发底层数据结构的变化。同时，数组和切片的元素是可以被直接修改的，因此可以对它们进行取址操作来实现参数传递、修改元素和实现数据结构等功能。在使用数组和切片的取址操作时，仍然需要注意并发安全和正确性问题，但相对于map，由于其内部结构的简单性，风险较小。</p>
<p>总而言之，在Go语言中，不允许对map进行取址操作是为了避免数据竞争和安全问题，而数组和切片则具备相对简单的内部结构和更明确的使用方式，因此允许进行取址操作。</p>
</blockquote>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><blockquote>
<p>本部分有待商榷</p>
</blockquote>
<h2 id="什么时候需要用指针封装map"><a href="#什么时候需要用指针封装map" class="headerlink" title="什么时候需要用指针封装map"></a>什么时候需要用指针封装map</h2><p>在 Go 中，大部分情况下，不需要对 map 进行指针封装。因为 map 本身是引用类型，在函数传递时传递的是指向底层数据结构的指针。这意味着在函数间传递 map 时，传递的是其引用而不是值的拷贝，因此可以直接对 map 进行操作而无需额外封装为指针。</p>
<p>然而，有些情况下可能需要对 map 进行指针封装：</p>
<h3 id="1-需要在多个函数中修改同一个-map"><a href="#1-需要在多个函数中修改同一个-map" class="headerlink" title="1. 需要在多个函数中修改同一个 map"></a>1. 需要在多个函数中修改同一个 map</h3><p>如果需要在多个函数中修改同一个 map 并且希望这些修改对所有函数都生效，可以使用指针封装。因为 map 是引用类型，传递指向 map 的指针可以确保在不同函数间共享相同的 map 实例，对 map 的修改可以在不同函数中体现出来。</p>
<h3 id="2-减少-map-的拷贝开销"><a href="#2-减少-map-的拷贝开销" class="headerlink" title="2. 减少 map 的拷贝开销"></a>2. 减少 map 的拷贝开销</h3><p>在某些情况下，当 map 很大并且需要在函数之间传递时，将 map 传递为指针可以减少拷贝的开销。大的 map 传递值拷贝可能会消耗较多的内存和时间，而传递指针则只需传递地址。</p>
<h3 id="3-需要避免-map-自身的nil指针问题"><a href="#3-需要避免-map-自身的nil指针问题" class="headerlink" title="3. 需要避免 map 自身的nil指针问题"></a>3. 需要避免 map 自身的nil指针问题</h3><p>在某些场景下，需要避免 map 本身可能出现 nil 指针的问题。通过使用指针封装 map，可以在 nil map 的情况下返回一个非 nil 的 map，避免出现空 map 操作时的错误。</p>
<p>当需要在多个函数中修改同一个 map 并确保修改对所有函数生效时，使用指针封装可以很有用。以下是示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MapStruct <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMapStruct</span><span class="params">()</span></span> *MapStruct &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;MapStruct&#123;</span><br><span class="line">        Data: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddData</span><span class="params">(m *MapStruct, key <span class="type">string</span>, value <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    m.Data[key] = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mapInstance := NewMapStruct()</span><br><span class="line"></span><br><span class="line">    AddData(mapInstance, <span class="string">&quot;Key1&quot;</span>, <span class="number">10</span>)</span><br><span class="line">    AddData(mapInstance, <span class="string">&quot;Key2&quot;</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">    fmt.Println(mapInstance.Data) <span class="comment">// 输出：map[Key1:10 Key2:20]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，<code>AddData</code>​ 函数接收一个 <code>MapStruct</code>​ 的指针作为参数，并向其 map 字段中添加键值对。在 <code>main</code>​ 函数中调用 <code>AddData</code>​ 两次来修改同一个 <code>MapStruct</code>​ 实例的 map，并最终输出修改后的 map 数据。</p>
<p>对于第二种情况，如果需要在多个函数之间传递大型的 map，通过指针封装可以避免大的 map 被复制多次，节省内存和提高效率。以下是一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ProcessMap</span><span class="params">(m *<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 对传入的 map 进行处理</span></span><br><span class="line">    (*m)[<span class="string">&quot;Key1&quot;</span>] = <span class="number">100</span></span><br><span class="line">    (*m)[<span class="string">&quot;Key2&quot;</span>] = <span class="number">200</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    myMap := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    ProcessMap(&amp;myMap)</span><br><span class="line"></span><br><span class="line">    fmt.Println(myMap) <span class="comment">// 输出：map[Key1:100 Key2:200]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>ProcessMap</code>​ 函数接收一个 <code>map[string]int</code>​ 类型的指针，并对传入的 map 进行操作。在 <code>main</code>​ 函数中调用 <code>ProcessMap</code>​ 函数，并传递了 <code>myMap</code>​ 的地址。通过指针传递，避免了对 <code>myMap</code>​ 进行复制，直接在原始的 map 上进行修改。</p>
<p>第三种情况，当需要避免 map 本身可能出现 nil 指针问题时，可以通过指针封装来确保 map 不会为 nil。以下是一个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MapWrapper <span class="keyword">struct</span> &#123;</span><br><span class="line">    Map *<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewMapWrapper</span><span class="params">()</span></span> *MapWrapper &#123;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">    <span class="keyword">return</span> &amp;MapWrapper&#123;Map: &amp;m&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mapWrapper := NewMapWrapper()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查 map 是否为 nil，如果是则初始化一个空的 map</span></span><br><span class="line">    <span class="keyword">if</span> *(mapWrapper.Map) == <span class="literal">nil</span> &#123;</span><br><span class="line">        *mapWrapper.Map = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    (*mapWrapper.Map)[<span class="string">&quot;Key1&quot;</span>] = <span class="string">&quot;Value1&quot;</span></span><br><span class="line">    (*mapWrapper.Map)[<span class="string">&quot;Key2&quot;</span>] = <span class="string">&quot;Value2&quot;</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(*mapWrapper.Map) <span class="comment">// 输出：map[Key1:Value1 Key2:Value2]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>MapWrapper</code>​ 结构体包含一个指向 <code>map[string]string</code>​ 类型的指针。<code>NewMapWrapper</code>​ 函数返回一个初始化过的 <code>MapWrapper</code>​ 实例，其中的 map 指针初始化为一个空的 map。然后在 <code>main</code>​ 函数中对 map 进行操作，并确保了 map 不会是 nil。</p>
<h2 id="关于map中的key可以是任意类型"><a href="#关于map中的key可以是任意类型" class="headerlink" title="关于map中的key可以是任意类型"></a>关于map中的key可以是任意类型</h2><p>为了说明值可以是任意类型的，这里给出了一个使用 func() int 作为值的 map——mf：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	mf := <span class="keyword">map</span>[<span class="type">int</span>]<span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span>&#123;</span><br><span class="line">		<span class="number">1</span>: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="number">10</span> &#125;,</span><br><span class="line">		<span class="number">2</span>: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="number">20</span> &#125;,</span><br><span class="line">		<span class="number">5</span>: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="number">50</span> &#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(mf)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为：map[1:0x53b9a0 2:0x53b9c0 5:0x53b9e0]</p>
<p>整形key的value值都被映射到了对应的函数地址</p>
<h2 id="用slice作为map的值"><a href="#用slice作为map的值" class="headerlink" title="用slice作为map的值"></a>用slice作为map的值</h2><p>既然一个 key 只能对应一个 value，而 value 又是一个原始类型，那么如果一个 key 要对应多个值怎么办？例如，当我们要处理unix机器上的所有进程，以父进程（pid 为整形）作为 key，所有的子进程（以所有子进程的 pid 组成的切片）作为value。通过将 value 定义为 []int 类型或者其他类型的切片，就可以优雅的解决这个问题。</p>
<p>这里有一些定义这种 map 的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mp1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">int</span>)</span><br><span class="line">mp2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*[]<span class="type">int</span>)</span><br></pre></td></tr></table></figure>

<p>示例中的 <code>mp1</code>​ 和 <code>mp2</code>​ 都是用来处理一个 key 对应多个值的情况。</p>
<ul>
<li>​<code>mp1 := make(map[int][]int)</code>​：这创建了一个 map，其中每个 key 是一个整数，而每个 value 是一个整数切片。这样，对于每个 key，你可以将其值设置为包含多个整数的切片，实现了一个 key 对应多个值的存储。</li>
<li>​<code>mp2 := make(map[int]*[]int)</code>​：这个 map 与上述的 <code>mp1</code>​ 稍有不同，它的 value 是指向整数切片的指针。这意味着每个 key 对应一个指向整数切片的指针，这样可以通过指针修改对应 key 的整数切片。</li>
</ul>
<p>举例说明：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 定义一个 map，每个 key 对应一个整数切片</span></span><br><span class="line">    mp1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">int</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 添加多个值到同一个 key 对应的切片中</span></span><br><span class="line">    mp1[<span class="number">1</span>] = <span class="built_in">append</span>(mp1[<span class="number">1</span>], <span class="number">10</span>)</span><br><span class="line">    mp1[<span class="number">1</span>] = <span class="built_in">append</span>(mp1[<span class="number">1</span>], <span class="number">20</span>)</span><br><span class="line">  </span><br><span class="line">    fmt.Println(mp1) <span class="comment">// 输出: map[1:[10 20]]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个 map，每个 key 对应一个整数切片的指针</span></span><br><span class="line">    mp2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*[]<span class="type">int</span>)</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 添加多个值到同一个 key 对应的切片中</span></span><br><span class="line">    slice := []<span class="type">int</span>&#123;<span class="number">30</span>, <span class="number">40</span>&#125;</span><br><span class="line">    mp2[<span class="number">2</span>] = &amp;slice</span><br><span class="line">  </span><br><span class="line">    fmt.Println(*mp2[<span class="number">2</span>]) <span class="comment">// 输出: [30 40]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些示例展示了如何使用这两种方式来实现一个 key 对应多个值的存储，并在需要时向切片中添加多个值。</p>
<p>在使用上，<code>map[int][]int</code>​ 和 <code>map[int]*[]int</code>​ 这两种方式有一些不同点：</p>
<ol>
<li><p><span style="font-weight: bold;" data-type="strong">数据所有权：</span></p>
<ul>
<li>​<code>map[int][]int</code>​：在这种情况下，切片是直接存储在 map 的值中，而不是指针。这意味着每个 key 对应的值都是独立的，修改一个 key 对应的切片不会影响其他 key。</li>
<li>​<code>map[int]*[]int</code>​：这种情况下，map 中的值是指向切片的指针。多个 key 可能共享相同的切片，因为它们都指向同一个切片。修改一个 key 对应的切片可能会影响其他 key。</li>
</ul>
</li>
<li><p><span style="font-weight: bold;" data-type="strong">内存管理和性能：</span></p>
<ul>
<li>​<code>map[int][]int</code>​：由于切片是直接存储在 map 中的值，这可能会增加内存使用量，尤其当值的数量较多时。但是，访问和修改数据的性能可能更好，因为它们是直接存储在 map 中的。</li>
<li>​<code>map[int]*[]int</code>​：这种情况下，指针存储在 map 中的值，实际的切片数据存储在堆上。它可能需要更多的内存，但在某些情况下，它可以减少复制和传递数据的开销，因为多个 key 可以共享相同的切片数据。</li>
</ul>
</li>
<li><p><span style="font-weight: bold;" data-type="strong">安全性：</span></p>
<ul>
<li>​<code>map[int][]int</code>​：由于切片是直接存储在 map 中的值，对一个 key 对应的切片的修改不会影响其他 key。这可以提供更好的安全性，因为每个 key 拥有独立的数据。</li>
<li>​<code>map[int]*[]int</code>​：当多个 key 共享同一个切片时，一个 key 的修改可能会影响其他 key，可能导致意外的数据修改。在多个地方使用同一个切片时，需要更小心地管理数据的修改。</li>
</ul>
</li>
</ol>
<p>因此，在使用时，需要根据具体的场景和需求来选择适当的方式。如果需要独立的数据副本或更好的数据安全性，<code>map[int][]int</code>​ 可能更适合；如果需要共享数据、降低内存占用或减少复制开销，<code>map[int]*[]int</code>​ 可能更适合。</p>
<p>这个差异的优缺点有待商榷</p>
<p>当使用 <code>map[int]*[]int</code>​ 的方式时，多个 key 可能共享相同的切片。因此，对一个 key 对应的切片的修改可能会影响其他 key。</p>
<p>举个例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	myMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*[]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建一个切片并将其地址存储在 map[1] 中</span></span><br><span class="line">	slice := []<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">20</span>&#125;</span><br><span class="line">	myMap[<span class="number">1</span>] = &amp;slice</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将 map[2] 指向 map[1] 所指向的切片</span></span><br><span class="line">	myMap[<span class="number">2</span>] = myMap[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 修改 map[1] 中的切片</span></span><br><span class="line">	*myMap[<span class="number">1</span>] = <span class="built_in">append</span>(*myMap[<span class="number">1</span>], <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 输出 map[2]，查看是否受到影响</span></span><br><span class="line">	fmt.Println(*myMap[<span class="number">2</span>]) <span class="comment">// 输出：[10 20 30]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们创建了一个 <code>map[int]*[]int</code>​ 类型的 map，将一个切片的地址存储在 map[1] 中。接着，我们将 map[2] 的值指向了 map[1] 所指向的同一个切片。</p>
<p>然后，我们修改了 map[1] 中的切片，通过在 map[1] 所指向的切片中添加一个新元素。接着，我们打印了 map[2] 的值，发现其值也发生了变化，因为 map[2] 实际上指向了 map[1] 所指向的同一个切片。</p>
<p>这就说明了当使用 <code>map[int]*[]int</code>​ 时，一个 key 的切片修改会影响到其他 key，因为它们指向的是相同的切片。</p>
<p><span style="font-weight: bold;" data-type="strong"><u>我的尝试：</u></span></p>
<p>指针所指向的地址相同的情况：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 定义一个 map，每个 key 对应一个整数切片</span></span><br><span class="line">	mp1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加多个值到同一个 key 对应的切片中</span></span><br><span class="line">	mp1[<span class="number">1</span>] = <span class="built_in">append</span>(mp1[<span class="number">1</span>], <span class="number">10</span>)</span><br><span class="line">	mp1[<span class="number">1</span>] = <span class="built_in">append</span>(mp1[<span class="number">1</span>], <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(mp1) <span class="comment">// 输出: map[1:[10 20]]</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义一个 map，每个 key 对应一个整数切片的指针</span></span><br><span class="line">	mp2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*[]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加多个值到同一个 key 对应的切片中</span></span><br><span class="line">	slice1 := []<span class="type">int</span>&#123;<span class="number">30</span>, <span class="number">40</span>&#125;</span><br><span class="line">	mp2[<span class="number">2</span>] = &amp;slice1</span><br><span class="line"></span><br><span class="line">	mp2[<span class="number">3</span>] = mp2[<span class="number">2</span>]</span><br><span class="line">	fmt.Println(*mp2[<span class="number">2</span>])</span><br><span class="line">	fmt.Println(*mp2[<span class="number">3</span>])</span><br><span class="line">	*mp2[<span class="number">2</span>] = <span class="built_in">append</span>(*mp2[<span class="number">2</span>], <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(*mp2[<span class="number">2</span>]) <span class="comment">// 输出: [30 40]</span></span><br><span class="line">	fmt.Println(*mp2[<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打印 mp2[2] 和 mp2[3] 指针所指向的地址</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Address of mp2[2]: %p\n&quot;</span>, mp2[<span class="number">2</span>])</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Address of mp2[3]: %p\n&quot;</span>, mp2[<span class="number">3</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果:</p>
<p>​<img src="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202312061749546.png" alt="image">​</p>
<p>‍</p>
<p>指针所指向的地址不相同的情况：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 定义一个 map，每个 key 对应一个整数切片</span></span><br><span class="line">	mp1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加多个值到同一个 key 对应的切片中</span></span><br><span class="line">	mp1[<span class="number">1</span>] = <span class="built_in">append</span>(mp1[<span class="number">1</span>], <span class="number">10</span>)</span><br><span class="line">	mp1[<span class="number">1</span>] = <span class="built_in">append</span>(mp1[<span class="number">1</span>], <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">	fmt.Println(mp1) <span class="comment">// 输出: map[1:[10 20]]</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义一个 map，每个 key 对应一个整数切片的指针</span></span><br><span class="line">	mp2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]*[]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 添加多个值到同一个 key 对应的切片中</span></span><br><span class="line">	slice1 := []<span class="type">int</span>&#123;<span class="number">30</span>, <span class="number">40</span>&#125;</span><br><span class="line">	mp2[<span class="number">2</span>] = &amp;slice1</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这里是一个新的实例，在内存中独立存在，与之前的slice1不同</span></span><br><span class="line">	slice2 := []<span class="type">int</span>&#123;<span class="number">30</span>, <span class="number">40</span>&#125;</span><br><span class="line">	mp2[<span class="number">3</span>] = &amp;slice2</span><br><span class="line"></span><br><span class="line">	fmt.Println(*mp2[<span class="number">2</span>]) <span class="comment">// 输出: [30 40]</span></span><br><span class="line">	fmt.Println(*mp2[<span class="number">3</span>])</span><br><span class="line">	<span class="comment">// 打印 mp2[2] 和 mp2[3] 指针所指向的地址</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Address of mp2[2]: %p\n&quot;</span>, mp2[<span class="number">2</span>])</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Address of mp2[3]: %p\n&quot;</span>, mp2[<span class="number">3</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p>​<img src="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202312061749191.png" alt="image">​</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>浅浅地理解map与slice的差异：</p>
<p>对于slice切片，它的核心强调的是容量，能装纳多少数据，但是map强调的是键值对的存储与索引</p>
<p>map底层更加复杂，在扩容上来讲，map扩容的效率要低，slice-&gt;数组；map-&gt;桶；map扩容操作时需要对所有键值对重新计算哈希值和桶的位置。这种操作需要花费更长的时间。</p>
<p>更深层次的理解见底层篇——《核心底层》</p>
<p>总结起来主要了以下几点：</p>
<ul>
<li>什么是map，map格式与数据类型限制【尤其是key】，map特征，如何创建以及初始化map</li>
<li>map的常规操作：访问，赋值，遍历，删除，判断key是否存在，获取长度等</li>
<li>map的嵌套</li>
</ul>
<p>其实还涉及很多问题，比如map的并发安全问题，syc.map相关，后续想到再巩固</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>重学Go语言 | Map</p><p><a href="https://luommy.github.io/post/re-learning-go-language-map-z1kmiya.html">https://luommy.github.io/post/re-learning-go-language-map-z1kmiya.html</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>luommy</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2023-12-05</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-12-06</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/golang/">golang</a></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/" alt="微信"></span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/" alt="支付宝"></span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>爱发电</span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/post/go-parallel-programming-chief-outline-znxfpt.html"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Go并发编程 | 总纲</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/post/my-distributed-goals-ktyod.html"><span class="level-item">分布式晋级之路</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="waline-thread"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@waline/client@2.6.3/dist/waline.css"><script src="https://cdn.jsdelivr.net/npm/@waline/client@2.6.3/dist/waline.js"></script><script>Waline.init({
            el: '#waline-thread',
            serverURL: "https://myblog-vercel.vercel.app/",
            path: window.location.pathname,
            lang: "zh-CN",
            
            emoji: ["https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo"],
            dark: "auto",
            meta: ["nick","mail","link"],
            requiredMeta: [],
            login: "disable",
            
            pageSize: 10,
            imageUploader: false,
            highlighter: false,
            texRenderer: false,
            search: false,
            pageview: false,
            comment: false,
            copyright: true,
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#重学Go语言-Map"><span class="level-left"><span class="level-item">1</span><span class="level-item">重学Go语言 | Map</span></span></a></li><li><a class="level is-mobile" href="#Map简述"><span class="level-left"><span class="level-item">2</span><span class="level-item">Map简述</span></span></a></li><li><a class="level is-mobile" href="#map格式与数据类型限制"><span class="level-left"><span class="level-item">3</span><span class="level-item">map格式与数据类型限制</span></span></a></li><li><a class="level is-mobile" href="#map的特征"><span class="level-left"><span class="level-item">4</span><span class="level-item">map的特征</span></span></a></li><li><a class="level is-mobile" href="#创建及初始化Map"><span class="level-left"><span class="level-item">5</span><span class="level-item">创建及初始化Map</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#未经初始化"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">未经初始化</span></span></a></li><li><a class="level is-mobile" href="#初始化方式"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">初始化方式</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#make函数"><span class="level-left"><span class="level-item">5.2.1</span><span class="level-item">make函数</span></span></a></li><li><a class="level is-mobile" href="#字面量初始化"><span class="level-left"><span class="level-item">5.2.2</span><span class="level-item">字面量初始化</span></span></a></li><li><a class="level is-mobile" href="#非要用new初始化"><span class="level-left"><span class="level-item">5.2.3</span><span class="level-item">非要用new初始化</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#常用操作"><span class="level-left"><span class="level-item">6</span><span class="level-item">常用操作</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#赋值与访问"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">赋值与访问</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#赋值"><span class="level-left"><span class="level-item">6.1.1</span><span class="level-item">赋值</span></span></a></li><li><a class="level is-mobile" href="#访问"><span class="level-left"><span class="level-item">6.1.2</span><span class="level-item">访问</span></span></a></li></ul></li><li><a class="level is-mobile" href="#判断key是否存在"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">判断key是否存在</span></span></a></li><li><a class="level is-mobile" href="#遍历"><span class="level-left"><span class="level-item">6.3</span><span class="level-item">遍历</span></span></a></li><li><a class="level is-mobile" href="#删除"><span class="level-left"><span class="level-item">6.4</span><span class="level-item">删除</span></span></a></li><li><a class="level is-mobile" href="#获取长度"><span class="level-left"><span class="level-item">6.5</span><span class="level-item">获取长度</span></span></a></li><li><a class="level is-mobile" href="#Map嵌套"><span class="level-left"><span class="level-item">6.6</span><span class="level-item">Map嵌套</span></span></a></li><li><a class="level is-mobile" href="#Map做函数参数"><span class="level-left"><span class="level-item">6.7</span><span class="level-item">Map做函数参数</span></span></a></li><li><a class="level is-mobile" href="#Map做函数返回值"><span class="level-left"><span class="level-item">6.8</span><span class="level-item">Map做函数返回值</span></span></a></li><li><a class="level is-mobile" href="#Map的排序"><span class="level-left"><span class="level-item">6.9</span><span class="level-item">Map的排序</span></span></a></li><li><a class="level is-mobile" href="#Map之间无法比较，只能与nil比较"><span class="level-left"><span class="level-item">6.10</span><span class="level-item">Map之间无法比较，只能与nil比较</span></span></a></li><li><a class="level is-mobile" href="#不能对Map的value进行取址操作"><span class="level-left"><span class="level-item">6.11</span><span class="level-item">不能对Map的value进行取址操作</span></span></a></li></ul></li><li><a class="level is-mobile" href="#补充"><span class="level-left"><span class="level-item">7</span><span class="level-item">补充</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#什么时候需要用指针封装map"><span class="level-left"><span class="level-item">7.1</span><span class="level-item">什么时候需要用指针封装map</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-需要在多个函数中修改同一个-map"><span class="level-left"><span class="level-item">7.1.1</span><span class="level-item">1. 需要在多个函数中修改同一个 map</span></span></a></li><li><a class="level is-mobile" href="#2-减少-map-的拷贝开销"><span class="level-left"><span class="level-item">7.1.2</span><span class="level-item">2. 减少 map 的拷贝开销</span></span></a></li><li><a class="level is-mobile" href="#3-需要避免-map-自身的nil指针问题"><span class="level-left"><span class="level-item">7.1.3</span><span class="level-item">3. 需要避免 map 自身的nil指针问题</span></span></a></li></ul></li><li><a class="level is-mobile" href="#关于map中的key可以是任意类型"><span class="level-left"><span class="level-item">7.2</span><span class="level-item">关于map中的key可以是任意类型</span></span></a></li><li><a class="level is-mobile" href="#用slice作为map的值"><span class="level-left"><span class="level-item">7.3</span><span class="level-item">用slice作为map的值</span></span></a></li></ul></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">8</span><span class="level-item">总结</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/golang/"><span class="tag">golang</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/timeline/"><span class="tag">timeline</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><span class="tag">并发编程</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%93%E5%AD%98/"><span class="tag">缓存</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%A2%86%E5%9F%9F%E7%AE%97%E6%B3%95/"><span class="tag">领域算法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"><span class="tag">知识体系</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/goland%E6%8A%80%E5%B7%A7/"><span class="tag">goland技巧</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Myblog/"><span class="tag">Myblog</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"><span class="tag">高并发</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mysql/"><span class="tag">mysql</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nacos/"><span class="tag">nacos</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="tag">操作系统</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-01-08T05:47:25.000Z">2024-01-08</time></p><p class="title"><a href="/post/three-core-themes-of-the-operating-system-z2lftgm.html">操作系统三大核心主题</a></p><p class="categories"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82/">计算机底层</a> / <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-01-03T08:09:58.000Z">2024-01-03</time></p><p class="title"><a href="/post/distributed-cache-global-cognition-11klor.html">分布式缓存全局认知</a></p><p class="categories"><a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E3%80%81%E6%9E%B6%E6%9E%84/">分布式、微服务、架构</a> / <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E3%80%81%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-28T02:40:09.000Z">2023-12-28</time></p><p class="title"><a href="/post/using-godebug-more-intuitively-to-understand-the-go-scheduling-process-z1bawyb.html">利用GODEBUG更直观地理解 Go 调度过程</a></p><p class="categories"><a href="/categories/Golang/">Golang</a> / <a href="/categories/Golang/%E6%A0%B8%E5%BF%83%E5%BA%95%E5%B1%82/">核心底层</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-26T05:42:26.000Z">2023-12-26</time></p><p class="title"><a href="/post/go-parallel-programming-channel-z13snhx.html">Go并发编程 | Channel</a></p><p class="categories"><a href="/categories/Golang/">Golang</a> / <a href="/categories/Golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-12T03:35:58.000Z">2023-12-12</time></p><p class="title"><a href="/post/gozen-me-rang-xie-cheng-pao-yi-ban-jiu-tui-chu-xipuv.html">Go怎么让协程跑一半就退出？</a></p><p class="categories"><a href="/categories/Golang/">Golang</a> / <a href="/categories/Golang/%E6%A0%B8%E5%BF%83%E5%BA%95%E5%B1%82/">核心底层</a></p></div></article></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="林庭晚阖" height="28"></a><p class="is-size-7"><span>&copy; 2024 luommy</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/mhchem.min.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><!-- hexo injector body_end start -->
  <script type="text/javascript" src="/custom/custom.js"></script>
<!-- hexo injector body_end end --></body></html>