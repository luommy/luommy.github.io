<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Go怎么让协程跑一半就退出？ - 林庭晚阖</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="林庭晚阖"><meta name="msapplication-TileImage" content="/img/kafka.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="林庭晚阖"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="认识goexit、理解GMP实例、函数栈、底层调度"><meta property="og:type" content="blog"><meta property="og:title" content="Go怎么让协程跑一半就退出？"><meta property="og:url" content="https://luommy.github.io/post/gozen-me-rang-xie-cheng-pao-yi-ban-jiu-tui-chu-xipuv.html"><meta property="og:site_name" content="林庭晚阖"><meta property="og:description" content="认识goexit、理解GMP实例、函数栈、底层调度"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202312121420729.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202312121420761.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202312121420477.gif"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202312121420656.jpg"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202312121420334.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202312121420259.gif"><meta property="article:published_time" content="2023-12-12T03:35:58.000Z"><meta property="article:modified_time" content="2023-12-12T06:22:00.000Z"><meta property="article:author" content="luommy"><meta property="article:tag" content="golang"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202312121420729.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://luommy.github.io/post/gozen-me-rang-xie-cheng-pao-yi-ban-jiu-tui-chu-xipuv.html"},"headline":"Go怎么让协程跑一半就退出？","image":["https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202312121420729.png","https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202312121420761.png","https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202312121420477.gif","https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202312121420656.jpg","https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202312121420334.png","https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202312121420259.gif"],"datePublished":"2023-12-12T03:35:58.000Z","dateModified":"2023-12-12T06:22:00.000Z","author":{"@type":"Person","name":"luommy"},"publisher":{"@type":"Organization","name":"林庭晚阖","logo":{"@type":"ImageObject","url":"https://luommy.github.io/img/logo.svg"}},"description":"认识goexit、理解GMP实例、函数栈、底层调度"}</script><link rel="canonical" href="https://luommy.github.io/post/gozen-me-rang-xie-cheng-pao-yi-ban-jiu-tui-chu-xipuv.html"><link rel="icon" href="/img/kafka.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/vs.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?ecf13ffee9f4083d9a74b337b541f90b";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script>
  <link rel="stylesheet" href="/custom/custom.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="林庭晚阖" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">文章</a><a class="navbar-item" href="/tags/timeline">心情</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/links.html">友链</a><a class="navbar-item" href="/guestbook.html">留言</a><a class="navbar-item" href="/about.html">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="发邮件" href="mailto:jdonglecool@163.com"><i class="fab fa-regular fa-envelope"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com/luommy"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-12-12T03:35:58.000Z" title="12/12/2023, 3:35:58 AM">2023-12-12</time>发表</span><span class="level-item"><time dateTime="2023-12-12T06:22:00.000Z" title="12/12/2023, 6:22:00 AM">2023-12-12</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Golang/">Golang</a><span> / </span><a class="link-muted" href="/categories/Golang/%E6%A0%B8%E5%BF%83%E5%BA%95%E5%B1%82/">核心底层</a></span><span class="level-item">19 分钟读完 (大约2883个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Go怎么让协程跑一半就退出？</h1><div class="content"><h1 id="Go怎么让协程跑一半就退出？"><a href="#Go怎么让协程跑一半就退出？" class="headerlink" title="Go怎么让协程跑一半就退出？"></a>Go怎么让协程跑一半就退出？</h1><blockquote>
<p>go中runtime.Goexit()可以让跑一半的协程退出？</p>
<p>我的第一反应是创建了一个<code>context.Context</code>​对象，并通过<code>context.WithCancel</code>​函数创建一个可以取消的上下文。然后，在协程中使用<code>select</code>​语句监听<code>ctx.Done()</code>​通道，当接收到退出信号时，协程会执行退出操作。</p>
<p>参考小白了解到了一些不一样的东西</p>
</blockquote>
<p>我的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">				fmt.Println(<span class="string">&quot;协程收到退出信号，退出&quot;</span>)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="comment">// 执行协程任务</span></span><br><span class="line">				fmt.Println(<span class="string">&quot;正在执行任务...&quot;</span>)</span><br><span class="line">				time.Sleep(time.Second)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(ctx)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待一段时间后取消协程</span></span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">	cancel()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待协程退出</span></span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;主线程退出&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们平时创建一个协程，跑一段逻辑，代码大概长这样。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;打印1&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;打印2&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;打印3&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span>  Foo()</span><br><span class="line">    fmt.Println(<span class="string">&quot;打印4&quot;</span>)</span><br><span class="line">    time.Sleep(<span class="number">1000</span>*time.Second)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 这段代码，正常运行会有下面的结果</span></span><br><span class="line">打印<span class="number">4</span></span><br><span class="line">打印<span class="number">1</span></span><br><span class="line">打印<span class="number">3</span></span><br><span class="line">打印<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p><span style="font-weight: bold;" data-type="strong">注意</span>这上面”​<span style="font-weight: bold;" data-type="strong">打印2</span>​”是在<code>defer</code>​中的，所以会在函数结束前打印。因此后置于”​<span style="font-weight: bold;" data-type="strong">打印3</span>​”。</p>
<p>那么今天的问题是，如何让<code>Foo()</code>​函数<span style="font-weight: bold;" data-type="strong">跑一半就结束</span>，比如说跑到<span style="font-weight: bold;" data-type="strong">打印2</span>，就退出协程（不让defer中的“3”打印）。输出如下结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">打印4</span><br><span class="line">打印1</span><br><span class="line">打印2</span><br></pre></td></tr></table></figure>

<p>如何实现？</p>
<p>答：在”打印2”后面插入一个 <code>runtime.Goexit()</code>​​， 协程就会直接结束。并且结束前还能执行到<code>defer</code>​​里的​<span style="font-weight: bold;" data-type="strong">打印2</span>​。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;打印1&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;打印2&quot;</span>)</span><br><span class="line">    runtime.Goexit() <span class="comment">// 加入这行代码 可实现打印2结束退出</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;打印3&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span>  Foo()</span><br><span class="line">    fmt.Println(<span class="string">&quot;打印4&quot;</span>)</span><br><span class="line">    time.Sleep(<span class="number">1000</span>*time.Second)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">打印<span class="number">4</span></span><br><span class="line">打印<span class="number">1</span></span><br><span class="line">打印<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>可以看到<span style="font-weight: bold;" data-type="strong">打印3</span>这一行没出现了，协程确实提前结束了。</p>
<h1 id="一图梗概"><a href="#一图梗概" class="headerlink" title="一图梗概"></a>一图梗概</h1><p>​<img src="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202312121420729.png" alt="image">​</p>
<h1 id="runtime-Goexit-是什么？"><a href="#runtime-Goexit-是什么？" class="headerlink" title="runtime.Goexit()是什么？"></a>runtime.Goexit()是什么？</h1><p>看一下内部实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Goexit</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 以下函数省略一些逻辑...</span></span><br><span class="line">    gp := getg() </span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// 获取defer并执行</span></span><br><span class="line">        d := gp._defer</span><br><span class="line">        reflectcall(<span class="literal">nil</span>, unsafe.Pointer(d.fn), deferArgs(d), <span class="type">uint32</span>(d.siz), <span class="type">uint32</span>(d.siz))</span><br><span class="line">    &#125;</span><br><span class="line">    goexit1()</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goexit1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mcall(goexit0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从代码上看，<code>runtime.Goexit()</code>​会先执行一下<code>defer</code>​里的方法，这里就解释了开头的代码里为什么<span style="font-weight: bold;" data-type="strong">在defer里的打印2</span>能正常输出。</p>
<p>然后代码再执行<code>goexit1</code>​。本质就是对<code>goexit0</code>​的简单封装。</p>
<p>我们可以把代码继续跟下去，看看<code>goexit0</code>​做了什么。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// goexit continuation on g0.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goexit0</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 获取当前的 goroutine</span></span><br><span class="line">    _g_ := getg()</span><br><span class="line">    <span class="comment">// 将当前goroutine的状态置为 _Gdead</span></span><br><span class="line">    casgstatus(gp, _Grunning, _Gdead)</span><br><span class="line">  <span class="comment">// 全局协程数减一</span></span><br><span class="line">    <span class="keyword">if</span> isSystemGoroutine(gp, <span class="literal">false</span>) &#123;</span><br><span class="line">        atomic.Xadd(&amp;sched.ngsys, <span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 省略各种清空逻辑...</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 把g从m上摘下来。</span></span><br><span class="line">  dropg()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 把这个g放回到p的本地协程队列里，放不下放全局协程队列。</span></span><br><span class="line">    gfput(_g_.m.p.ptr(), gp)</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 重新调度，拿下一个可运行的协程出来跑</span></span><br><span class="line">    schedule()</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>这段代码，信息密度比较大。</p>
<p>很多名词可能让人一脸懵。</p>
<p>简单描述下，Go语言里有个<span style="font-weight: bold;" data-type="strong">GMP模型</span>的说法，<code>M</code>​是内核线程，<code>G</code>​也就是我们平时用的协程<code>goroutine</code>​，<code>P</code>​会在<code>G和M之间</code>​做工具人，负责<span style="font-weight: bold;" data-type="strong">调度</span>​<code>G</code>​到<code>M</code>​上运行。</p>
<p>​<img src="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202312121420761.png" alt="图片" title="GMP模型">  </p>
<p>既然是​<span style="font-weight: bold;" data-type="strong">调度</span>​，也就是说不是每个<code>G</code>​都能一直处于运行状态，等G不能运行时，就把它存起来，再<span style="font-weight: bold;" data-type="strong">调度</span>下一个能运行的G过来运行。</p>
<p>暂时不能运行的G，P上会有个<span style="font-weight: bold;" data-type="strong">本地队列</span>去存放这些这些G，P的本地队列存不下的话，还有个全局队列，干的事情也类似。</p>
<p>了解这个背景后，再回到 <code>goexit0</code>​ 方法看看，做的事情就是将当前的协程G置为<code>_Gdead</code>​状态（说白了这个runtime.Goexit()就是让这个线程去死），即：然后把它从M上摘下来，尝试放回到P的本地队列中。然后重新调度一波，获取另一个能跑的G（看看其它有没有能跑的协程），拿出来跑。</p>
<p>​<img src="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202312121420477.gif" alt="图片" title="goexit函数：P调度可用的G到M上">  </p>
<p>所以简单总结一下：<span style="font-weight: bold;" data-type="strong">只要执行 goexit 这个函数，当前协程就会退出，同时还能调度下一个可执行的协程出来跑。</span></p>
<p>这就是为什么<code>runtime.Goexit()</code>​能让协程只执行一半就结束了。</p>
<h1 id="goexit的用途"><a href="#goexit的用途" class="headerlink" title="goexit的用途"></a>goexit的用途</h1><p>我理解是：堆栈底层 “御用” 退出方法</p>
<p>正经人谁会没事跑一半协程就结束呢？所以<code>goexit</code>​的<span style="font-weight: bold;" data-type="strong">真实用途</span>是啥？</p>
<p>有个​<span style="font-weight: bold;" data-type="strong">小细节</span>​，不知道大家平时debug的时候有没有关注过。</p>
<p>​<img src="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202312121420656.jpg" alt="图片" title="小细节">​</p>
<p>为了说明问题，这里先给出一段代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;打印1&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span>  Foo()</span><br><span class="line">    fmt.Println(<span class="string">&quot;打印3&quot;</span>)</span><br><span class="line">    time.Sleep(<span class="number">1000</span>*time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是一段非常简单的代码，输出什么完全不重要。通过<code>go</code>​关键字启动了一个<code>goroutine</code>​执行<code>Foo()</code>​，里面打印一下就结束，主协程<code>sleep</code>​很长时间，只为​<span style="font-weight: bold;" data-type="strong">死等</span>​。</p>
<p>这里我们新启动的协程里，在<code>Foo()</code>​函数内随便打个断点。然后<code>debug</code>​一下。</p>
<p>​<img src="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202312121420334.png" alt="图片" title="null">​</p>
<p>会发现，这个协程的堆栈底部是从<code>runtime.goexit()</code>​里开始启动的。</p>
<p>如果大家平时有注意观察，会发现，​<span style="font-weight: bold;" data-type="strong">其实所有的堆栈底部，都是从这个函数开始的</span>​。我们继续跟跟代码。</p>
<h1 id="goexit是什么？"><a href="#goexit是什么？" class="headerlink" title="goexit是什么？"></a>goexit是什么？</h1><p>从上面的<code>debug</code>​堆栈里点进去会发现，这是个汇编函数，可以看出调用的是<code>runtime</code>​包内的 <code>goexit1()</code>​ 函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The top-most function running on a goroutine</span></span><br><span class="line"><span class="comment">// returns to goexit+PCQuantum.</span></span><br><span class="line">TEXT runtime·goexit(SB),NOSPLIT,$<span class="number">0</span><span class="number">-0</span></span><br><span class="line">    BYTE    $<span class="number">0x90</span>    <span class="comment">// NOP</span></span><br><span class="line">    CALL    runtime·goexit1(SB)    <span class="comment">// does not return</span></span><br><span class="line">    <span class="comment">// traceback from goexit1 must hit code range of goexit</span></span><br><span class="line">    BYTE    $<span class="number">0x90</span>    <span class="comment">// NOP</span></span><br></pre></td></tr></table></figure>

<p>于是跟到了<code>pruntime/proc.go</code>​里的代码中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略部分代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goexit1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mcall(goexit0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>是不是很熟悉，这不就是我们开头讲<code>runtime.Goexit()</code>​里内部执行的<code>goexit0</code>​吗。</p>
<h1 id="为什么每个堆栈底部都是这个方法？"><a href="#为什么每个堆栈底部都是这个方法？" class="headerlink" title="为什么每个堆栈底部都是这个方法？"></a>为什么每个堆栈底部都是这个方法？</h1><p>因为只要创建协程就有<code>newproc1</code>​这个方法，它获取当前协程G所在的调度器P，然后创建一个新G，并在栈底插入一个goexit</p>
<p>我们首先需要知道的是，函数栈的执行过程，是先进后出。</p>
<p>假设我们有以下代码</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    B()</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">B</span><span class="params">()</span></span> &#123;</span><br><span class="line">    A()</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码是main运行B函数，B函数再运行A函数，代码执行时就跟下面的动图那样。</p>
<p>​<img src="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202312121420259.gif" alt="动态演示" title="函数堆栈执行顺序">  </p>
<p>这个是先进后出的过程，也就是我们常说的函数栈，执行完<span style="font-weight: bold;" data-type="strong">子函数A()</span> 后，就会回到<span style="font-weight: bold;" data-type="strong">父函数B()</span> 中，执行完<span style="font-weight: bold;" data-type="strong">B()后</span>，最后就会回到<span style="font-weight: bold;" data-type="strong">main()</span> 。这里的栈底是<code>main()</code>​，如果在<span style="font-weight: bold;" data-type="strong">栈底</span>插入的是 <code>goexit</code>​ 的话，那么当程序执行结束的时候就都能执行到<code>goexit</code>​里去。</p>
<p>结合前面讲过的内容，我们就能知道，此时栈底的<code>goexit</code>​，会在协程内的业务代码跑完后被执行到，从而实现协程退出，并调度下一个<span style="font-weight: bold;" data-type="strong">可执行的G</span>来运行。</p>
<p> <u><em>——那么问题又来了，栈底插入</em></u>​<code>&lt;u&gt;*goexit*&lt;/u&gt;</code>​<u><em>这件事是谁做的，什么时候做的？</em></u></p>
<p>直接说答案，这个在<code>runtime/proc.go</code>​里有个<code>newproc1</code>​方法，只要是<span style="font-weight: bold;" data-type="strong">创建协程</span>都会用到这个方法（main是主协程也不例外）。</p>
<p>里面有个地方是这么写的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc1</span><span class="params">(fn *funcval, argp unsafe.Pointer, narg <span class="type">int32</span>, callergp *g, callerpc <span class="type">uintptr</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前g</span></span><br><span class="line">  _g_ := getg()</span><br><span class="line">    <span class="comment">// 获取当前g所在的p</span></span><br><span class="line">    _p_ := _g_.m.p.ptr()</span><br><span class="line">  <span class="comment">// 创建一个新 goroutine</span></span><br><span class="line">    newg := gfget(_p_)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 底部插入goexit</span></span><br><span class="line">    newg.sched.pc = funcPC(goexit) + sys.PCQuantum </span><br><span class="line">    newg.sched.g = guintptr(unsafe.Pointer(newg))</span><br><span class="line">    <span class="comment">// 把新创建的g放到p中</span></span><br><span class="line">    runqput(_p_, newg, <span class="literal">true</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>主要的逻辑是获取当前协程G所在的调度器P，然后创建一个新G，并在栈底插入一个goexit。</p>
<p>所以我们每次debug的时候，就都能看到函数栈底部有个goexit函数。</p>
<h1 id="main函数也是个协程，栈底也是goexit？"><a href="#main函数也是个协程，栈底也是goexit？" class="headerlink" title="main函数也是个协程，栈底也是goexit？"></a>main函数也是个协程，栈底也是goexit？</h1><p>关于main函数栈底是不是也有个<code>goexit</code>​，我们对下面代码断点看下。直接得出结果。</p>
<pre><code>​![图片](https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202312121420770.png &quot;null&quot;)​
</code></pre>
<p>main函数栈底也是<code>goexit()</code>​</p>
<p>从 <code>asm_amd64.s</code>​可以看到Go程序启动的流程，这里提到的 <code>runtime·mainPC</code>​ 其实就是 <code>runtime.main</code>​.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// create a new goroutine to start program</span><br><span class="line">MOVQ    $runtime·mainPC(SB), AX        // 也就是runtime.main</span><br><span class="line">PUSHQ    AX</span><br><span class="line">PUSHQ    $0            // arg size</span><br><span class="line">CALL    runtime·newproc(SB)</span><br></pre></td></tr></table></figure>

<p>通过<code>runtime·newproc</code>​创建<code>runtime.main</code>​协程，然后在<code>runtime.main</code>​里会启动<code>main.main</code>​函数，这个就是我们平时写的那个main函数了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/proc.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 省略大量代码</span></span><br><span class="line">    fn := main_main <span class="comment">// 其实就是我们的main函数入口</span></span><br><span class="line">    fn() </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//go:linkname main_main main.main</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main_main</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>结论是，<span style="font-weight: bold;" data-type="strong">其实main函数也是由newproc创建的，只要通过newproc创建的goroutine，栈底就会有一个goexit。</span></p>
<h1 id="os-Exit-和runtime-Goexit-有什么区别"><a href="#os-Exit-和runtime-Goexit-有什么区别" class="headerlink" title="os.Exit()和runtime.Goexit()有什么区别"></a>os.Exit()和runtime.Goexit()有什么区别</h1><p>最后再回到开头的问题，实现一下首尾呼应。</p>
<p>开头的面试题，除了<code>runtime.Goexit()</code>​，是不是还可以改为用<code>os.Exit()</code>​？</p>
<p>同样都是带有”退出”的含义，两者退出的<span style="font-weight: bold;" data-type="strong">对象</span>不同。<code>os.Exit()</code>​ 指的是整个<span style="font-weight: bold;" data-type="strong">进程</span>退出；而<code>runtime.Goexit()</code>​指的是<span style="font-weight: bold;" data-type="strong">协程</span>退出。</p>
<p>可想而知，改用<code>os.Exit()</code>​ 这种情况下，defer里的内容就不会被执行到了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;打印1&quot;</span>)</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">&quot;打印2&quot;</span>)</span><br><span class="line">    os.Exit(<span class="number">0</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;打印3&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span>  Foo()</span><br><span class="line">    fmt.Println(<span class="string">&quot;打印4&quot;</span>)</span><br><span class="line">    time.Sleep(<span class="number">1000</span>*time.Second)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">打印<span class="number">4</span></span><br><span class="line">打印<span class="number">1</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><p>通过 <code>runtime.Goexit()</code>​可以做到提前结束协程，且结束前还能执行到defer的内容</p>
</li>
<li><p>​<code>runtime.Goexit()</code>​其实是对<code>goexit0</code>​的封装，只要执行 <code>goexit0</code>​这个函数，当前协程就会退出，同时还能调度下一个可执行的协程出来跑。</p>
</li>
<li><p>通过<code>newproc</code>​可以创建出新的<code>goroutine</code>​，它会在函数栈底部插入一个<code>goexit</code>​</p>
</li>
<li><p>​<code>os.Exit()</code>​ 指的是整个<span style="font-weight: bold;" data-type="strong">进程</span>退出；而<code>runtime.Goexit()</code>​指的是<span style="font-weight: bold;" data-type="strong">协程</span>退出。两者含义有区别！</p>
</li>
</ul>
<p>‍</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Go怎么让协程跑一半就退出？</p><p><a href="https://luommy.github.io/post/gozen-me-rang-xie-cheng-pao-yi-ban-jiu-tui-chu-xipuv.html">https://luommy.github.io/post/gozen-me-rang-xie-cheng-pao-yi-ban-jiu-tui-chu-xipuv.html</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>luommy</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2023-12-12</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-12-12</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/golang/">golang</a></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/" alt="微信"></span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/" alt="支付宝"></span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>爱发电</span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/post/go-parallel-programming-channel-z13snhx.html"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Go并发编程 | Channel</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/post/20231207-thursday-1igq3d.html"><span class="level-item">2023-12-07 星期四</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="waline-thread"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@waline/client@2.6.3/dist/waline.css"><script src="https://cdn.jsdelivr.net/npm/@waline/client@2.6.3/dist/waline.js"></script><script>Waline.init({
            el: '#waline-thread',
            serverURL: "https://myblog-vercel.vercel.app/",
            path: window.location.pathname,
            lang: "zh-CN",
            
            emoji: ["https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo"],
            dark: "auto",
            meta: ["nick","mail","link"],
            requiredMeta: [],
            login: "disable",
            
            pageSize: 10,
            imageUploader: false,
            highlighter: false,
            texRenderer: false,
            search: false,
            pageview: false,
            comment: false,
            copyright: true,
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Go怎么让协程跑一半就退出？"><span class="level-left"><span class="level-item">1</span><span class="level-item">Go怎么让协程跑一半就退出？</span></span></a></li><li><a class="level is-mobile" href="#一图梗概"><span class="level-left"><span class="level-item">2</span><span class="level-item">一图梗概</span></span></a></li><li><a class="level is-mobile" href="#runtime-Goexit-是什么？"><span class="level-left"><span class="level-item">3</span><span class="level-item">runtime.Goexit()是什么？</span></span></a></li><li><a class="level is-mobile" href="#goexit的用途"><span class="level-left"><span class="level-item">4</span><span class="level-item">goexit的用途</span></span></a></li><li><a class="level is-mobile" href="#goexit是什么？"><span class="level-left"><span class="level-item">5</span><span class="level-item">goexit是什么？</span></span></a></li><li><a class="level is-mobile" href="#为什么每个堆栈底部都是这个方法？"><span class="level-left"><span class="level-item">6</span><span class="level-item">为什么每个堆栈底部都是这个方法？</span></span></a></li><li><a class="level is-mobile" href="#main函数也是个协程，栈底也是goexit？"><span class="level-left"><span class="level-item">7</span><span class="level-item">main函数也是个协程，栈底也是goexit？</span></span></a></li><li><a class="level is-mobile" href="#os-Exit-和runtime-Goexit-有什么区别"><span class="level-left"><span class="level-item">8</span><span class="level-item">os.Exit()和runtime.Goexit()有什么区别</span></span></a></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">9</span><span class="level-item">总结</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/timeline/"><span class="tag">timeline</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/golang/"><span class="tag">golang</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><span class="tag">并发编程</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%A2%86%E5%9F%9F%E7%AE%97%E6%B3%95/"><span class="tag">领域算法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"><span class="tag">知识体系</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/goland%E6%8A%80%E5%B7%A7/"><span class="tag">goland技巧</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"><span class="tag">高并发</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Myblog/"><span class="tag">Myblog</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mysql/"><span class="tag">mysql</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nacos/"><span class="tag">nacos</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-26T05:42:26.000Z">2023-12-26</time></p><p class="title"><a href="/post/go-parallel-programming-channel-z13snhx.html">Go并发编程 | Channel</a></p><p class="categories"><a href="/categories/Golang/">Golang</a> / <a href="/categories/Golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-12T03:35:58.000Z">2023-12-12</time></p><p class="title"><a href="/post/gozen-me-rang-xie-cheng-pao-yi-ban-jiu-tui-chu-xipuv.html">Go怎么让协程跑一半就退出？</a></p><p class="categories"><a href="/categories/Golang/">Golang</a> / <a href="/categories/Golang/%E6%A0%B8%E5%BF%83%E5%BA%95%E5%B1%82/">核心底层</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-07T06:14:50.000Z">2023-12-07</time></p><p class="title"><a href="/post/20231207-thursday-1igq3d.html">2023-12-07 星期四</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-06T10:14:22.000Z">2023-12-06</time></p><p class="title"><a href="/post/go-concurrent-programming-mutex-2f1e0r.html">Go并发编程 | Mutex</a></p><p class="categories"><a href="/categories/Golang/">Golang</a> / <a href="/categories/Golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-06T09:50:18.000Z">2023-12-06</time></p><p class="title"><a href="/post/go-parallel-programming-chief-outline-znxfpt.html">Go并发编程 | 总纲</a></p><p class="categories"><a href="/categories/Golang/">Golang</a> / <a href="/categories/Golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></p></div></article></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="林庭晚阖" height="28"></a><p class="is-size-7"><span>&copy; 2023 luommy</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/mhchem.min.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><!-- hexo injector body_end start -->
  <script type="text/javascript" src="/custom/custom.js"></script>
<!-- hexo injector body_end end --></body></html>