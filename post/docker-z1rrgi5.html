<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Docker一文通览 - 林庭晚阖</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="林庭晚阖"><meta name="msapplication-TileImage" content="/img/kafka.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="林庭晚阖"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="docker系列一文通览，依据认知持续更新..."><meta property="og:type" content="blog"><meta property="og:title" content="Docker一文通览"><meta property="og:url" content="https://luommy.github.io/post/docker-z1rrgi5.html"><meta property="og:site_name" content="林庭晚阖"><meta property="og:description" content="docker系列一文通览，依据认知持续更新..."><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141653367.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141653192.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141653254.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141653399.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141653329.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141653473.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141653694.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141654933.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141654638.png"><meta property="og:image" content="https://luommy.github.io/undefined"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141654753.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141654157.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141654610.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141654853.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141654821.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141654171.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141654176.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141654473.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141654542.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141654476.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141654677.png"><meta property="article:published_time" content="2023-11-14T08:52:28.000Z"><meta property="article:modified_time" content="2023-11-14T08:52:28.000Z"><meta property="article:author" content="luommy"><meta property="article:tag" content="docker"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141653367.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://luommy.github.io/post/docker-z1rrgi5.html"},"headline":"Docker一文通览","image":["https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141653367.png","https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141653192.png","https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141653254.png","https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141653399.png","https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141653329.png","https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141653473.png","https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141653694.png","https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141654933.png","https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141654638.png","https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141654753.png","https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141654157.png","https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141654610.png","https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141654853.png","https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141654821.png","https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141654171.png","https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141654176.png","https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141654473.png","https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141654542.png","https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141654476.png","https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141654677.png"],"datePublished":"2023-11-14T08:52:28.000Z","dateModified":"2023-11-14T08:52:28.000Z","author":{"@type":"Person","name":"luommy"},"publisher":{"@type":"Organization","name":"林庭晚阖","logo":{"@type":"ImageObject","url":"https://luommy.github.io/img/logo.svg"}},"description":"docker系列一文通览，依据认知持续更新..."}</script><link rel="canonical" href="https://luommy.github.io/post/docker-z1rrgi5.html"><link rel="icon" href="/img/kafka.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/vs.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?ecf13ffee9f4083d9a74b337b541f90b";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script>
  <link rel="stylesheet" href="/custom/custom.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="林庭晚阖" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">文章</a><a class="navbar-item" href="/tags/timeline">心情</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/links.html">友链</a><a class="navbar-item" href="/guestbook.html">留言</a><a class="navbar-item" href="/about.html">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="发邮件" href="mailto:jdonglecool@163.com"><i class="fab fa-regular fa-envelope"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com/luommy"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-11-14T08:52:28.000Z" title="11/14/2023, 8:52:28 AM">2023-11-14</time>发表</span><span class="level-item"><time dateTime="2023-11-14T08:52:28.000Z" title="11/14/2023, 8:52:28 AM">2023-11-14</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Docker/">Docker</a></span><span class="level-item">1 小时读完 (大约13176个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">Docker一文通览</h1><div class="content"><h1 id="Docker通览"><a href="#Docker通览" class="headerlink" title="Docker通览"></a>Docker通览</h1><blockquote>
<p>通览篇主要是构建基本的认知，本篇从基础概念、应用、核心底层组成，甚至包括一点点个人理解。</p>
</blockquote>
<h1 id="Docker基础与应用"><a href="#Docker基础与应用" class="headerlink" title="Docker基础与应用"></a>Docker基础与应用</h1><ul>
<li>官方文档地址:<a target="_blank" rel="noopener" href="https://www.docker.com/get-started">https://www.docker.com/get-started</a></li>
<li>中文参考手册:<a target="_blank" rel="noopener" href="https://docker_practice.gitee.io/zh-cn/">https://docker_practice.gitee.io/zh-cn/</a></li>
</ul>
<hr>
<h2 id="什么是-Docker"><a href="#什么是-Docker" class="headerlink" title="什么是 Docker"></a>什么是 Docker</h2><h3 id="官方定义"><a href="#官方定义" class="headerlink" title="官方定义"></a>官方定义</h3><ul>
<li>最新官网首页</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141653367.png" alt="image-20201220213306128"></p>
<p><img src="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141653192.png" alt="image-20201220214210994"></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.官方介绍</span></span><br><span class="line"><span class="bullet">-</span> We have a complete container solution for you - no matter who you are and where you are on your containerization journey.</span><br><span class="line"><span class="bullet">-</span> 翻译: 我们为你提供了一个完整的容器解决方案,不管你是谁,不管你在哪,你都可以开始容器的的旅程。</span><br><span class="line"><span class="bullet">-</span> 官方定义: docker是一个容器技术。</span><br></pre></td></tr></table></figure>

<h3 id="Docker的起源"><a href="#Docker的起源" class="headerlink" title="Docker的起源"></a>Docker的起源</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Docker 最初是 dotCloud 公司创始人 Solomon Hykes 在法国期间发起的一个公司内部项目，它是基于 dotCloud 公司多年云服务技术的一次革新，并于 2013 年 3 月以 Apache 2.0 授权协议开源，主要项目代码在 GitHub 上进行维护。Docker 项目后来还加入了 Linux 基金会，并成立推动 开放容器联盟（OCI）。</span><br><span class="line"></span><br><span class="line">Docker 自开源后受到广泛的关注和讨论，至今其 GitHub 项目 已经超过 5 万 7 千个星标和一万多个 fork。甚至由于 Docker 项目的火爆，在 2013 年底，dotCloud 公司决定改名为 Docker。Docker 最初是在 Ubuntu 12.04 上开发实现的；Red Hat 则从 RHEL 6.5 开始对 Docker 进行支持；Google 也在其 PaaS 产品中广泛应用 Docker。</span><br><span class="line"></span><br><span class="line">Docker 使用 Google 公司推出的 Go 语言 进行开发实现，基于 Linux 内核的 cgroup，namespace，以及 OverlayFS 类的 Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术。由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。</span><br></pre></td></tr></table></figure>

<h2 id="为什么是Docker"><a href="#为什么是Docker" class="headerlink" title="为什么是Docker"></a>为什么是Docker</h2><ul>
<li><p><code>在开发的时候，在本机测试环境可以跑，生产环境跑不起来</code></p>
<p>这里我们拿java Web应用程序举例，我们一个java Web应用程序涉及很多东西，比如jdk、tomcat、mysql等软件环境。当这些其中某一项版本不一致的时候，可能就会导致应用程序跑不起来这种情况。Docker 则将程序以及使用软件环境直接打包在一起，无论在那个机器上保证了环境一致。</p>
<p><strong>优势1:  一致的运行环境,更轻松的迁移</strong></p>
</li>
<li><p><code>服务器自己的程序挂了，结果发现是别人程序出了问题把内存吃完了，自己程序因为内存不够就挂了</code></p>
<p>这种也是一种比较常见的情况，如果你的程序重要性不是特别高的话，公司基本上不可能让你的程序独享一台服务器的，这时候你的服务器就会跟公司其他人的程序共享一台服务器，所以不可避免地就会受到其他程序的干扰，导致自己的程序出现问题。Docker就很好解决了环境隔离的问题，别人程序不会影响到自己的程序。</p>
<p><strong>优势2：对进程进行封装隔离,容器与容器之间互不影响,更高效的利用系统资源</strong></p>
</li>
<li><p><code>公司要弄一个活动，可能会有大量的流量进来，公司需要再多部署几十台服务器</code></p>
<p>在没有Docker的情况下，要在几天内部署几十台服务器，这对运维来说是一件非常折磨人的事，而且每台服务器的环境还不一定一样，就会出现各种问题，最后部署地头皮发麻。用Docker的话，我只需要将程序打包到镜像，你要多少台服务，我就给力跑多少容器，极大地提高了部署效率。</p>
<p><strong>优势3: 通过镜像复制N多个环境一致容器</strong></p>
</li>
</ul>
<hr>
<h2 id="Docker和虚拟机区别"><a href="#Docker和虚拟机区别" class="headerlink" title="Docker和虚拟机区别"></a>Docker和虚拟机区别</h2><blockquote>
<p>关于Docker与虚拟机的区别，我在网上找到的一张图，非常直观形象地展示出来，话不多说，直接上图。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141653254.png" alt="image-20201220222456675"></p>
<p><code>比较上面两张图，我们发现虚拟机是携带操作系统，本身很小的应用程序却因为携带了操作系统而变得非常大，很笨重</code>。Docker是不携带操作系统的，所以Docker的应用就非常的轻巧。另外在调用宿主机的CPU、磁盘等等这些资源的时候，拿内存举例，虚拟机是利用Hypervisor去虚拟化内存，整个调用过程是虚拟内存-&gt;虚拟物理内存-&gt;真正物理内存，但是Docker是利用Docker Engine去调用宿主的的资源，这时候过程是虚拟内存-&gt;真正物理内存。</p>
<table>
<thead>
<tr>
<th></th>
<th>传统虚拟机</th>
<th>Docker容器</th>
</tr>
</thead>
<tbody><tr>
<td>磁盘占用</td>
<td>几个GB到几十个GB左右</td>
<td>几十MB到几百MB左右</td>
</tr>
<tr>
<td>CPU内存占用</td>
<td>虚拟操作系统非常占用CPU和内存</td>
<td>Docker引擎占用极低</td>
</tr>
<tr>
<td>启动速度</td>
<td>（从开机到运行项目）几分钟</td>
<td>（从开启容器到运行项目）几秒</td>
</tr>
<tr>
<td>安装管理</td>
<td>需要专门的运维技术</td>
<td>安装、管理方便</td>
</tr>
<tr>
<td>应用部署</td>
<td>每次部署都费时费力</td>
<td>从第二次部署开始轻松简捷</td>
</tr>
<tr>
<td>耦合性</td>
<td>多个应用服务安装到一起，容易互相影响</td>
<td>每个应用服务一个容器，达成隔离</td>
</tr>
<tr>
<td>系统依赖</td>
<td>无</td>
<td>需求相同或相似的内核，目前推荐是Linux</td>
</tr>
</tbody></table>
<hr>
<h2 id="Docker的安装"><a href="#Docker的安装" class="headerlink" title="Docker的安装"></a>Docker的安装</h2><h3 id="安装docker-centos7-x"><a href="#安装docker-centos7-x" class="headerlink" title="安装docker(centos7.x)"></a>安装docker(centos7.x)</h3><ul>
<li><p>卸载原始docker</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure></li>
<li><p>安装docker依赖</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo yum install -y yum-utils \</span></span><br><span class="line"><span class="language-bash">  device-mapper-persistent-data \</span></span><br><span class="line"><span class="language-bash">  lvm2</span></span><br></pre></td></tr></table></figure></li>
<li><p>设置docker的yum源</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure></li>
<li><p>安装最新版的docker</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure></li>
<li><p>指定版本安装docker</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ yum list docker-ce --showduplicates | <span class="built_in">sort</span> -r</span><br><span class="line">$ sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io</span><br><span class="line">$ sudo yum install docker-ce-18.09.5-3.el7 docker-ce-cli-18.09.5-3.el7 containerd.io</span><br></pre></td></tr></table></figure></li>
<li><p>启动docker</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl <span class="built_in">enable</span> docker</span><br><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure></li>
<li><p>关闭docker</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl stop docker</span><br></pre></td></tr></table></figure>

<ul>
<li><p>测试docker安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run hello-world</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="bash安装-通用所有平台"><a href="#bash安装-通用所有平台" class="headerlink" title="bash安装(通用所有平台)"></a>bash安装(通用所有平台)</h3><ul>
<li><p>在测试或开发环境中 Docker 官方为了简化安装流程，提供了一套便捷的安装脚本，CentOS 系统上可以使用这套脚本安装，另外可以通过 <code>--mirror</code> 选项使用国内源进行安装：执行这个命令后，脚本就会自动的将一切准备工作做好，并且把 Docker 的稳定(stable)版本安装在系统中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSL get.docker.com -o get-docker.sh</span><br><span class="line">$ sudo sh get-docker.sh --mirror Aliyun</span><br></pre></td></tr></table></figure></li>
<li><p>启动docker</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl <span class="built_in">enable</span> docker</span><br><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure></li>
<li><p>创建docker用户组</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo groupadd docker</span><br></pre></td></tr></table></figure></li>
<li><p>将当前用户加入docker组</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo usermod -aG docker <span class="variable">$USER</span></span><br></pre></td></tr></table></figure></li>
<li><p>测试docker安装是否正确</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run hello-world</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Docker-的核心架构"><a href="#Docker-的核心架构" class="headerlink" title="Docker 的核心架构"></a>Docker 的核心架构</h2><p>​<img src="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141653399.png" alt="image-20200404111908085">​</p>
<ul>
<li>​<code>镜像:</code>​ 一个镜像代表一个应用环境,他是一个只读的文件,如 mysql镜像,tomcat镜像,nginx镜像等</li>
<li>​<code>容器:</code>​ 镜像每次运行之后就是产生一个容器,就是正在运行的镜像,特点就是可读可写</li>
<li>​<code>仓库:</code>​用来存放镜像的位置,类似于maven仓库,也是镜像下载和上传的位置</li>
<li>​<code>dockerFile:</code>​docker生成镜像配置文件,用来书写自定义镜像的一些配置</li>
<li>​<code>tar:</code>​一个对镜像打包的文件,日后可以还原成镜像</li>
</ul>
<p>​<img src="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141653329.png" alt="image">​</p>
<h2 id="Docker-配置阿里镜像加速服务"><a href="#Docker-配置阿里镜像加速服务" class="headerlink" title="Docker 配置阿里镜像加速服务"></a>Docker 配置阿里镜像加速服务</h2><h3 id="docker-运行流程"><a href="#docker-运行流程" class="headerlink" title="docker 运行流程"></a>docker 运行流程</h3><p><img src="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141653473.png" alt="image-20200404120356784"></p>
<h3 id="docker配置阿里云镜像加速"><a href="#docker配置阿里云镜像加速" class="headerlink" title="docker配置阿里云镜像加速"></a>docker配置阿里云镜像加速</h3><ul>
<li><code>访问阿里云登录自己账号查看docker镜像加速服务</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://lz2nib3q.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<ul>
<li><code>验证docker的镜像加速是否生效</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker info</span><br><span class="line">		..........</span><br><span class="line">    127.0.0.0/8</span><br><span class="line">   Registry Mirrors:</span><br><span class="line">    &#x27;https://lz2nib3q.mirror.aliyuncs.com/&#x27;</span><br><span class="line">   Live Restore Enabled: false</span><br><span class="line">   Product License: Community Engine</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Docker的入门应用"><a href="#Docker的入门应用" class="headerlink" title="Docker的入门应用"></a>Docker的入门应用</h2><h3 id="docker-的第一个程序"><a href="#docker-的第一个程序" class="headerlink" title="docker 的第一个程序"></a>docker 的第一个程序</h3><blockquote>
<p>docker  run hello-world</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# docker run hello-world</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"><span class="meta prompt_"> $ </span><span class="language-bash">docker run -it ubuntu bash</span></span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https://hub.docker.com/</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="启动命令"><a href="#启动命令" class="headerlink" title="启动命令"></a>启动命令</h3><p>启动docker</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>

<p>关闭docker</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure>

<p>重启docker</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>docker设置随服务启动而自启动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure>

<h3 id="辅助命令"><a href="#辅助命令" class="headerlink" title="辅助命令"></a>辅助命令</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.安装完成辅助命令</span></span><br><span class="line"><span class="code">		docker version	--------------------------	查看docker的信息</span></span><br><span class="line"><span class="code">		docker info		--------------------------	查看更详细的信息</span></span><br><span class="line"><span class="code">		docker --help	--------------------------	帮助命令</span></span><br></pre></td></tr></table></figure>

<h3 id="Images-镜像命令"><a href="#Images-镜像命令" class="headerlink" title="Images 镜像命令"></a>Images 镜像命令</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.查看本机中所有镜像</span></span><br><span class="line"><span class="code">	docker images	--------------------------	列出本地所有镜像</span></span><br><span class="line"><span class="code">		-a			列出所有镜像（包含中间映像层）</span></span><br><span class="line"><span class="code">  		-q			只显示镜像id</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 2.搜索镜像</span></span><br><span class="line"><span class="code">	docker search [options] 镜像名	-------------------	去dockerhub上查询当前镜像</span></span><br><span class="line"><span class="code">		-s 指定值		列出收藏数不少于指定值的镜像</span></span><br><span class="line"><span class="code">  		--no-trunc	  显示完整的镜像信息</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 3.从仓库下载镜像/拉取仓库镜像到本地</span></span><br><span class="line"><span class="code">	docker pull 镜像名[:TAG|@DIGEST]	----------------- 下载镜像</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 4.删除镜像</span></span><br><span class="line"><span class="code">	docker rmi 镜像名	--------------------------  删除镜像</span></span><br><span class="line"><span class="code">		-f		强制删除</span></span><br><span class="line"><span class="code">		如果删除多个镜像用空格隔开</span></span><br><span class="line"><span class="code">	删除全部镜像  -a 意思为显示全部, -q 意思为只显示ID</span></span><br><span class="line"><span class="code">	docker rmi -f $(docker images -aq)</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 5.加载本地件tar，恢复为镜像</span></span><br><span class="line"><span class="code">	docker load -i 本地文件  与docker save对应</span></span><br><span class="line"><span class="code">	docker load -i hello.tar</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 6.保存镜像为本地文件（打包镜像）**</span></span><br><span class="line"><span class="code">	docker save -o 镜像保存位置与名字 镜像名/镜像ID 与docker load对应</span></span><br><span class="line"><span class="code">	docker save -o hello.tar hello-world</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 7.上传镜像到docker hub</span></span><br><span class="line"><span class="code">	docker push hello:V1</span></span><br><span class="line"><span class="code"></span></span><br></pre></td></tr></table></figure>

<p>search:</p>
<p>​<img src="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141653694.png" alt="图片">​</p>
<p>​<code>docker 安装镜像时如果不指定安装的版本默认最新版本</code>​</p>
<h3 id="Contrainer-容器命令"><a href="#Contrainer-容器命令" class="headerlink" title="Contrainer 容器命令"></a>Contrainer 容器命令</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.运行容器</span></span><br><span class="line"><span class="code">	docker run 镜像名	--------------------------	镜像名新建并启动容器</span></span><br><span class="line"><span class="code">    --name 							   别名为容器起一个名字</span></span><br><span class="line"><span class="code">    -d, --detach					   启动守护式容器（在后台启动容器）</span></span><br><span class="line"><span class="code">    -p 								   映射端口号：原始端口号		 指定端口号启动</span></span><br><span class="line"><span class="code">  	-v, --volume list                  给容器挂载数据卷</span></span><br><span class="line"><span class="code">    --name string                      指定容器名称</span></span><br><span class="line"><span class="code"> 	-e, --env list                     设置容器环境变量</span></span><br><span class="line"><span class="code">  	-i, --interactive                  以交互模式运行容器，通常与 -t 同时使用</span></span><br><span class="line"><span class="code">  	-m, --memory bytes                 容器内存上限</span></span><br><span class="line"><span class="code"> 	-t, --tty                          为容器重新分配一个伪输入终端，通常与 -i 同时使用</span></span><br><span class="line"><span class="code">  	-w, --workdir string               指定工作目录</span></span><br><span class="line"><span class="code"> </span></span><br><span class="line"><span class="code">	例：docker run -it --name myTomcat -p 8888:8080 tomcat</span></span><br><span class="line"><span class="code">   	 docker run -d --name myTomcat -P tomcat</span></span><br><span class="line"><span class="code"> </span></span><br><span class="line"><span class="code">	常用换行的方式：</span></span><br><span class="line"><span class="code">	docker run -dit \</span></span><br><span class="line"><span class="code"> 		-v $PWD/ql/config:/ql/config \</span></span><br><span class="line"><span class="code">  		-p 5600:5600 \</span></span><br><span class="line"><span class="code">  		--name qinglong \</span></span><br><span class="line"><span class="code">  		--hostname qinglong \</span></span><br><span class="line"><span class="code">  		--restart unless-stopped \</span></span><br><span class="line"><span class="code">  		whyour/qinglong:2.11.3</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 2.查看运行的容器</span></span><br><span class="line"><span class="code">	docker ps					--------------------------	列出所有正在运行的容器</span></span><br><span class="line"><span class="code">	-a			正在运行的和历史运行过的容器（已经停止）</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 4.删除容器</span></span><br><span class="line"><span class="code">	docker rm -f 容器id和容器名   </span></span><br><span class="line"><span class="code">	docker rm -f $(docker ps -aq)		--------------------------	删除所有容器</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 5.查看容器内进程</span></span><br><span class="line"><span class="code">	docker top 容器id或者容器名 ------------------ 查看容器内的进程</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 6.查看查看容器内部细节</span></span><br><span class="line"><span class="code">	docker inspect 容器id 		------------------ 查看容器内部细节</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 7.查看容器的运行日志</span></span><br><span class="line"><span class="code">	docker logs [OPTIONS] 容器id或容器名	------------------ 查看容器日志</span></span><br><span class="line"><span class="code">    -t			 加入时间戳</span></span><br><span class="line"><span class="code">    -f			 跟随最新的日志打印</span></span><br><span class="line"><span class="code">    --tail 	 数字	显示最后多少条</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 8.进入容器内部</span></span><br><span class="line"><span class="code">	docker exec [options] 容器id 容器内命令 ------------------ 进入容器执行命令</span></span><br><span class="line"><span class="code">	-i		以交互模式运行容器，通常与-t一起使用</span></span><br><span class="line"><span class="code">    -t		分配一个伪终端    shell窗口   bash </span></span><br><span class="line"><span class="code">	常用：docker exec -it redis sh</span></span><br><span class="line"><span class="code"> 	或者使用docker attach 容器名/容器ID【 不常用 】---没有使用过....</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 9.容器和宿主机之间复制文件</span></span><br><span class="line"><span class="code">	docker cp 文件|目录 容器id:容器路径           -----------------   将宿主机复制到容器内部</span></span><br><span class="line"><span class="code">	docker cp 容器id:容器内资源路径 宿主机目录路径  -----------------   将容器内资源拷贝到主机上</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 10.数据卷(volum)实现与宿主机共享目录</span></span><br><span class="line"><span class="code">	docker run -v 宿主机的路径|任意别名:/容器内的路径 镜像名</span></span><br><span class="line"><span class="code">		注意: </span></span><br><span class="line"><span class="code">				1.如果是宿主机路径必须是绝对路径,宿主机目录会覆盖容器内目录内容</span></span><br><span class="line"><span class="code">				2.如果是别名则会在docker运行容器时自动在宿主机中创建一个目录,并将容器目录文件复制到宿主机中</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 11.打包镜像</span></span><br><span class="line"><span class="code">		docker save 镜像名 -o  名称.tar</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 12.载入镜像</span></span><br><span class="line"><span class="code">		docker load -i   名称.tar</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 13.容器打包成新的镜像</span></span><br><span class="line"><span class="code">	  	docker commit -m &quot;描述信息&quot; -a &quot;作者信息&quot;   （容器id或者名称）打包的镜像名称:标签</span></span><br></pre></td></tr></table></figure>

<p>补充：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.开机自启</span></span><br><span class="line"><span class="code">	docker update --restart=always 容器Id/容器名</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 2.更换容器名字</span></span><br><span class="line"><span class="code">	docker rename 容器ID/容器名字 新容器名字</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 3.查看docker磁盘</span></span><br><span class="line"><span class="code">	docker system df</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 4.查看容器占用内存</span></span><br><span class="line"><span class="code">	docker stats 容器名/容器ID</span></span><br><span class="line"><span class="code">	docker stats redis</span></span><br></pre></td></tr></table></figure>

<p>查看docker磁盘占用</p>
<p>​<img src="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141654933.png" alt="图片">​</p>
<ul>
<li>​<code>SIZE</code>​（大小）：表示Docker系统中各个部分（镜像、容器、卷、构建缓存）所占用的总磁盘空间大小，以字节为单位。</li>
<li>​<code>RECLAIMABLE</code>​（可回收大小）：表示可以通过清理或删除不再使用的资源来释放的磁盘空间大小，同样以字节为单位。</li>
</ul>
<p>docker save 与docker export区别：</p>
<ul>
<li>docker export需要指定容器(container)，不能像docker save那样指定镜像(image)或容器(container)都可以。</li>
<li>docker save保存的是镜像（image），docker export保存的是容器（container）；</li>
<li>docker load用来载入镜像包，docker import用来载入容器包，但两者都会恢复为镜像；</li>
<li>docker load不能对载入的镜像重命名，而docker import可以为镜像指定新名称。</li>
<li>docker save的应用场景是，如果你的应用是使用docker-compose.yml编排的多个镜像组合，但你要部署的客户服务器并不能连外网。这时，你可以使用docker save将用到的镜像打个包，然后拷贝到客户服务器上使用docker load载入 <strong>。—这一点</strong>​***<u>深有体会</u>***</li>
<li>docker export的应用场景主要用来制作基础镜像，比如你从一个ubuntu镜像启动一个容器，然后安装一些软件和进行一些设置后，使用docker export保存为一个基础镜像。然后，把这个镜像分发给其他人使用，比如作为基础的开发环境。—这个确实没有应用过</li>
</ul>
<hr>
<h2 id="docker的镜像原理"><a href="#docker的镜像原理" class="headerlink" title="docker的镜像原理"></a>docker的镜像原理</h2><h3 id="镜像是什么？"><a href="#镜像是什么？" class="headerlink" title="镜像是什么？"></a>镜像是什么？</h3><blockquote>
<p>镜像是一种轻量级的，可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时所需的库、环境变量和配置文件。</p>
</blockquote>
<h3 id="为什么一个镜像会那么大？"><a href="#为什么一个镜像会那么大？" class="headerlink" title="为什么一个镜像会那么大？"></a>为什么一个镜像会那么大？</h3><p><img src="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141654638.png" alt="image-20200404142950068"></p>
<p><code>镜像就是花卷</code></p>
<ul>
<li><p>UnionFS（联合文件系统）:</p>
<p>Union文件系统是一种分层，轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。Union文件系统是Docker镜像的基础。这种文件系统特性:就是一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录 。</p>
</li>
</ul>
<h3 id="Docker镜像原理"><a href="#Docker镜像原理" class="headerlink" title="Docker镜像原理"></a>Docker镜像原理</h3><blockquote>
<p><code>docker的镜像实际是由一层一层的文件系统组成。</code></p>
</blockquote>
<ul>
<li>bootfs（boot file system）主要包含bootloader和kernel，bootloader主要是引导加载kernel，Linux刚启动时会加载bootfs文件系统。在docker镜像的最底层就是bootfs。这一层与Linux&#x2F;Unix 系统是一样的，包含boot加载器（bootloader）和内核（kernel）。当boot加载完,后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时会卸载bootfs。</li>
<li>rootfs（root file system），在bootfs之上，包含的就是典型的linux系统中的&#x2F;dev，&#x2F;proc，&#x2F;bin，&#x2F;etc等标准的目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu&#x2F;CentOS等等。</li>
<li>我们平时安装进虚拟机的centos都有1到几个GB，为什么docker这里才200MB？对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令，工具，和程序库就可以了，因为底层直接使用Host的Kernal，自己只需要提供rootfs就行了。由此可见不同的linux发行版，他们的bootfs是一致的，rootfs会有差别。因此不同的发行版可以共用bootfs。</li>
</ul>
<p><img src="/undefined"></p>
<h3 id="为什么docker镜像要采用这种分层结构呢"><a href="#为什么docker镜像要采用这种分层结构呢" class="headerlink" title="为什么docker镜像要采用这种分层结构呢?"></a>为什么docker镜像要采用这种分层结构呢?</h3><blockquote>
<p><code>最大的一个好处就是资源共享</code></p>
</blockquote>
<ul>
<li>比如：有多个镜像都是从相同的base镜像构建而来的，那么宿主机只需在磁盘中保存一份base镜像。同时内存中也只需要加载一份base镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。Docker镜像都是只读的。当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称为容器层，容器层之下都叫镜像层。</li>
</ul>
<hr>
<h2 id="Docker安装常用服务"><a href="#Docker安装常用服务" class="headerlink" title="Docker安装常用服务"></a>Docker安装常用服务</h2><h3 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.拉取mysql镜像到本地</span></span><br><span class="line"><span class="code">	docker pull mysql:tag (tag不加默认最新版本)</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code"># 2.运行mysql服务</span></span><br><span class="line"><span class="code">	docker run --name mysql -e MYSQL_ROOT_PASSWORD=root -d mysql:tag  						  --没有暴露外部端口外部不能连接</span></span><br><span class="line"><span class="code">	docker run --name mysql -e MYSQL_ROOT_PASSWORD=root -p 3306:3306 -d  mysql:tag  --没有暴露外部端口</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 3.进入mysql容器</span></span><br><span class="line"><span class="code">	docker exec -it 容器名称|容器id bash</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 4.外部查看mysql日志</span></span><br><span class="line"><span class="code">	docker logs 容器名称|容器id</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 5.使用自定义配置参数</span></span><br><span class="line"><span class="code">	docker run --name mysql -v /root/mysql/conf.d:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root -d mysql:tag</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 6.将容器数据位置与宿主机位置挂载保证数据安全</span></span><br><span class="line"><span class="code">	docker run --name mysql -v /root/mysql/data:/var/lib/mysql -v /root/mysql/conf.d:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=root -p 3306:3306 -d mysql:tag</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 7.通过其他客户端访问 如在window系统|macos系统使用客户端工具访问</span></span><br><span class="line"><span class="code">	</span></span><br><span class="line"><span class="code"># 8.将mysql数据库备份为sql文件</span></span><br><span class="line"><span class="code">	docker exec mysql|容器id sh -c &#x27;exec mysqldump --all-databases -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;&#x27; &gt; /root/all-databases.sql  --导出全部数据</span></span><br><span class="line"><span class="code">	docker exec mysql sh -c &#x27;exec mysqldump --databases 库表 -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;&#x27; &gt; /root/all-databases.sql  --导出指定库数据</span></span><br><span class="line"><span class="code">	docker exec mysql sh -c &#x27;exec mysqldump --no-data --databases 库表 -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;&#x27; &gt; /root/all-databases.sql  --导出指定库数据不要数据</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 9.执行sql文件到mysql中</span></span><br><span class="line"><span class="code">	docker exec -i mysql sh -c &#x27;exec mysql -uroot -p&quot;$MYSQL_ROOT_PASSWORD&quot;&#x27; &lt; /root/xxx.sql</span></span><br></pre></td></tr></table></figure>

<h3 id="安装Redis服务"><a href="#安装Redis服务" class="headerlink" title="安装Redis服务"></a>安装Redis服务</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.在docker hub搜索redis镜像</span></span><br><span class="line"><span class="code">	docker search redis</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 2.拉取redis镜像到本地</span></span><br><span class="line"><span class="code">	docker pull redis</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 3.启动redis服务运行容器</span></span><br><span class="line"><span class="code">	docker run --name redis -d redis:tag (没有暴露外部端口)</span></span><br><span class="line"><span class="code">	docker run --name redis -p 6379:6379 -d redis:tag (暴露外部宿主机端口为6379进行连接) </span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 4.查看启动日志</span></span><br><span class="line"><span class="code">	docker logs -t -f 容器id|容器名称</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 5.进入容器内部查看</span></span><br><span class="line"><span class="code">	docker exec -it 容器id|名称 bash  </span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 6.加载外部自定义配置启动redis容器</span></span><br><span class="line"><span class="code">	默认情况下redis官方镜像中没有redis.conf配置文件 需要去官网下载指定版本的配置文件</span></span><br><span class="line"><span class="code">	1. wget http://download.redis.io/releases/redis-5.0.8.tar.gz  下载官方安装包</span></span><br><span class="line"><span class="code">	2. 将官方安装包中配置文件进行复制到宿主机指定目录中如 /root/redis/redis.conf文件</span></span><br><span class="line"><span class="code">	3. 修改需要自定义的配置</span></span><br><span class="line"><span class="code">		 bind 0.0.0.0 开启远程权限</span></span><br><span class="line"><span class="code">		 appenonly yes 开启aof持久化</span></span><br><span class="line"><span class="code">	4. 加载配置启动</span></span><br><span class="line"><span class="code">	docker run --name redis -v /root/redis:/usr/local/etc/redis -p 6379:6379 -d redis redis-server /usr/local/etc/redis/redis.conf  </span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 7.将数据目录挂在到本地保证数据安全</span></span><br><span class="line"><span class="code">	docker run --name redis -v /root/redis/data:/data -v /root/redis/redis.conf:/usr/local/etc/redis/redis.conf -p 6379:6379 -d redis redis-server 					/usr/local/etc/redis/redis.conf  </span></span><br></pre></td></tr></table></figure>

<h3 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.在docker hub搜索nginx</span></span><br><span class="line"><span class="code">	docker search nginx</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 2.拉取nginx镜像到本地</span></span><br><span class="line"><span class="code">	[root@localhost ~]# docker pull nginx</span></span><br><span class="line"><span class="code">    Using default tag: latest</span></span><br><span class="line"><span class="code">    latest: Pulling from library/nginx</span></span><br><span class="line"><span class="code">    afb6ec6fdc1c: Pull complete </span></span><br><span class="line"><span class="code">    b90c53a0b692: Pull complete </span></span><br><span class="line"><span class="code">    11fa52a0fdc0: Pull complete </span></span><br><span class="line"><span class="code">    Digest: sha256:30dfa439718a17baafefadf16c5e7c9d0a1cde97b4fd84f63b69e13513be7097</span></span><br><span class="line"><span class="code">    Status: Downloaded newer image for nginx:latest</span></span><br><span class="line"><span class="code">    docker.io/library/nginx:latest</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 3.启动nginx容器</span></span><br><span class="line"><span class="code">		docker run -p 80:80 --name nginx01 -d nginx</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 4.进入容器</span></span><br><span class="line"><span class="code">		docker exec -it nginx01 /bin/bash</span></span><br><span class="line"><span class="code">		查找目录:  whereis nginx</span></span><br><span class="line"><span class="code">		配置文件:  /etc/nginx/nginx.conf</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 5.复制配置文件到宿主机</span></span><br><span class="line"><span class="code">		docker cp nginx01(容器id|容器名称):/etc/nginx/nginx.conf 宿主机名录</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 6.挂在nginx配置以及html到宿主机外部</span></span><br><span class="line"><span class="code">		docker run --name nginx02 -v /root/nginx/nginx.conf:/etc/nginx/nginx.conf -v /root/nginx/html:/usr/share/nginx/html -p 80:80 -d nginx		</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="安装Tomcat"><a href="#安装Tomcat" class="headerlink" title="安装Tomcat"></a>安装Tomcat</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.在docker hub搜索tomcat</span></span><br><span class="line"><span class="code">	docker search tomcat</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 2.下载tomcat镜像</span></span><br><span class="line"><span class="code">	docker pull tomcat</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 3.运行tomcat镜像</span></span><br><span class="line"><span class="code">	docker run -p 8080:8080 -d --name mytomcat tomcat</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 4.进入tomcat容器</span></span><br><span class="line"><span class="code">	docker exec -it mytomcat /bin/bash</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 5.将webapps目录挂载在外部</span></span><br><span class="line"><span class="code">	docker run -p 8080:8080 -v /root/webapps:/usr/local/tomcat/webapps -d --name mytomcat tomcat</span></span><br><span class="line"><span class="code"></span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="安装MongoDB数据库"><a href="#安装MongoDB数据库" class="headerlink" title="安装MongoDB数据库"></a>安装MongoDB数据库</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.运行mongDB</span></span><br><span class="line"><span class="code">	docker run -d -p 27017:27017 --name mymongo mongo  ---无须权限</span></span><br><span class="line"><span class="code">	docker logs -f mymongo --查看mongo运行日志</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 2.进入mongodb容器</span></span><br><span class="line"><span class="code">	docker exec -it mymongo /bin/bash</span></span><br><span class="line"><span class="code">		直接执行mongo命令进行操作</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 3.常见具有权限的容器</span></span><br><span class="line"><span class="code">	docker run --name  mymongo  -p 27017:27017  -d mongo --auth</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 4.进入容器配置用户名密码</span></span><br><span class="line"><span class="code">	mongo</span></span><br><span class="line"><span class="code">	use admin 选择admin库</span></span><br><span class="line"><span class="code">	db.createUser(&#123;user:&quot;root&quot;,pwd:&quot;root&quot;,roles:[&#123;role:&#x27;root&#x27;,db:&#x27;admin&#x27;&#125;]&#125;)   //创建用户,此用户创建成功,则后续操作都需要用户认证</span></span><br><span class="line"><span class="code">	exit</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 5.将mongoDB中数据目录映射到宿主机中</span></span><br><span class="line"><span class="code">	docker run -d -p 27017:27017 -v /root/mongo/data:/data/db --name mymongo mongo </span></span><br></pre></td></tr></table></figure>

<h3 id="安装ElasticSearch"><a href="#安装ElasticSearch" class="headerlink" title="安装ElasticSearch"></a>安装ElasticSearch</h3><ul>
<li><code>注意:</code>​<strong>调高JVM线程数限制数量</strong></li>
</ul>
<h4 id="拉取镜像运行elasticsearch"><a href="#拉取镜像运行elasticsearch" class="headerlink" title="拉取镜像运行elasticsearch"></a>拉取镜像运行elasticsearch</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.dockerhub 拉取镜像</span></span><br><span class="line"><span class="code">	docker pull elasticsearch:6.4.2</span></span><br><span class="line"><span class="code"># 2.查看docker镜像</span></span><br><span class="line"><span class="code">	docker images</span></span><br><span class="line"><span class="code"># 3.运行docker镜像</span></span><br><span class="line"><span class="code">	docker run -p 9200:9200 -p 9300:9300 elasticsearch:6.4.2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>启动出现如下错误</li>
<li><img src="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141654753.png" alt="image-20200602184321790"></li>
</ul>
<h4 id="预先配置"><a href="#预先配置" class="headerlink" title="预先配置"></a>预先配置</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.在centos虚拟机中，修改配置sysctl.conf</span></span><br><span class="line"><span class="code">	vim /etc/sysctl.conf</span></span><br><span class="line"><span class="code"># 2.加入如下配置</span></span><br><span class="line"><span class="code">	vm.max_map_count=262144 </span></span><br><span class="line"><span class="code"># 3.启用配置</span></span><br><span class="line"><span class="code">	sysctl -p</span></span><br><span class="line"><span class="code">	注：这一步是为了防止启动容器时，报出如下错误：</span></span><br><span class="line"><span class="code">	bootstrap checks failed max virtual memory areas vm.max_map_count [65530] likely too low, increase to at least [262144]</span></span><br><span class="line"><span class="code"></span></span><br></pre></td></tr></table></figure>

<h4 id="启动EleasticSearch容器"><a href="#启动EleasticSearch容器" class="headerlink" title="启动EleasticSearch容器"></a>启动EleasticSearch容器</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 0.复制容器中data目录到宿主机中</span></span><br><span class="line"><span class="code">	docker cp 容器id:/usr/share/share/elasticsearch/data /root/es</span></span><br><span class="line"><span class="code"># 1.运行ES容器 指定jvm内存大小并指定ik分词器位置</span></span><br><span class="line"><span class="code">	docker run -d --name es -p 9200:9200 -p 9300:9300 -e ES_JAVA_OPTS=&quot;-Xms128m -Xmx128m&quot; -v /root/es/plugins:/usr/share/elasticsearch/plugins -v /root/es/data:/usr/share/elasticsearch/data elasticsearch:6.4.2</span></span><br></pre></td></tr></table></figure>

<h4 id="安装IK分词器"><a href="#安装IK分词器" class="headerlink" title="安装IK分词器"></a>安装IK分词器</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.下载对应版本的IK分词器</span></span><br><span class="line"><span class="code">	wget https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.4.2/elasticsearch-analysis-ik-6.4.2.zip</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 2.解压到plugins文件夹中</span></span><br><span class="line"><span class="code">	yum install -y unzip</span></span><br><span class="line"><span class="code">	unzip -d ik elasticsearch-analysis-ik-6.4.2.zip</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 3.添加自定义扩展词和停用词</span></span><br><span class="line"><span class="code">	cd plugins/elasticsearch/config</span></span><br><span class="line"><span class="code">	vim IKAnalyzer.cfg.xml</span></span><br><span class="line"><span class="code">	&lt;properties&gt;</span></span><br><span class="line"><span class="code">		&lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt;</span></span><br><span class="line"><span class="code">		&lt;!--用户可以在这里配置自己的扩展字典 --&gt;</span></span><br><span class="line"><span class="code">		&lt;entry key=&quot;ext_dict&quot;&gt;ext_dict.dic&lt;/entry&gt;</span></span><br><span class="line"><span class="code">		&lt;!--用户可以在这里配置自己的扩展停止词字典--&gt;</span></span><br><span class="line"><span class="code">		&lt;entry key=&quot;ext_stopwords&quot;&gt;ext_stopwords.dic&lt;/entry&gt;</span></span><br><span class="line"><span class="code">	&lt;/properties&gt;</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 4.在ik分词器目录下config目录中创建ext<span class="emphasis">_dict.dic文件   编码一定要为UTF-8才能生效</span></span></span><br><span class="line"><span class="emphasis"><span class="section">	vim ext_</span>dict.dic 加入扩展词即可</span></span><br><span class="line"><span class="section"># 5. 在ik分词器目录下config目录中创建ext<span class="emphasis">_stopword.dic文件 </span></span></span><br><span class="line"><span class="emphasis"><span class="section">	vim ext_</span>stopwords.dic 加入停用词即可</span></span><br><span class="line"></span><br><span class="line"><span class="section"># 6.重启容器生效</span></span><br><span class="line"><span class="code">	docker restart 容器id</span></span><br><span class="line"><span class="code"># 7.将此容器提交成为一个新的镜像</span></span><br><span class="line"><span class="code">	docker commit -a=&quot;xiaochen&quot; -m=&quot;es with IKAnalyzer&quot; 容器id xiaochen/elasticsearch:6.4.2</span></span><br></pre></td></tr></table></figure>

<h4 id="安装Kibana"><a href="#安装Kibana" class="headerlink" title="安装Kibana"></a>安装Kibana</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.下载kibana镜像到本地</span></span><br><span class="line"><span class="code">	docker pull kibana:6.4.2</span></span><br><span class="line"><span class="code"></span></span><br><span class="line"><span class="section"># 2.启动kibana容器</span></span><br><span class="line"><span class="code">	docker run -d --name kibana -e ELASTICSEARCH_URL=http://10.15.0.3:9200 -p 5601:5601 kibana:6.4.2</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Docker中出现如下错误解决方案"><a href="#Docker中出现如下错误解决方案" class="headerlink" title="Docker中出现如下错误解决方案"></a>Docker中出现如下错误解决方案</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">root</span>@<span class="type">localhost</span> ~]<span class="comment"># docker search mysql 或者 docker pull 这些命令无法使用</span></span><br><span class="line">Error response from daemon: Get https://index.docker.io/v1/search?q=mysql&amp;n=<span class="number">25</span>: x509: certificate has expired or is not yet valid</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141654157.png" alt="image-20200602183429286"></p>
<ul>
<li>注意:<strong>这个错误的原因在于是系统的时间和docker hub时间不一致,需要做系统时间与网络时间同步</strong></li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.安装时间同步</span></span><br><span class="line"><span class="code">	sudo yum -y install ntp ntpdate</span></span><br><span class="line"><span class="code"># 2.同步时间</span></span><br><span class="line"><span class="code">	sudo ntpdate cn.pool.ntp.org</span></span><br><span class="line"><span class="code"># 3.查看本机时间</span></span><br><span class="line"><span class="code">	date</span></span><br><span class="line"><span class="code"># 4.从新测试</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141654610.png" alt="image-20200602183718623"></p>
<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><h3 id="什么是Dockerfile"><a href="#什么是Dockerfile" class="headerlink" title="什么是Dockerfile"></a>什么是Dockerfile</h3><p>Dockerfile可以认为是<strong>Docker镜像的描述文件，是由一系列命令和参数构成的脚本</strong>。主要作用是<strong>用来构建docker镜像的构建文件</strong>。</p>
<p>​<img src="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141654853.png" alt="image-20200404111908085">​</p>
<ul>
<li><strong>通过架构图可以看出通过DockerFile可以直接构建镜像</strong></li>
</ul>
<h3 id="Dockerfile解析过程"><a href="#Dockerfile解析过程" class="headerlink" title="Dockerfile解析过程"></a>Dockerfile解析过程</h3><p><img src="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141654821.png" alt="image-20200603181253804"></p>
<h3 id="Dockerfile的保留命令"><a href="#Dockerfile的保留命令" class="headerlink" title="Dockerfile的保留命令"></a>Dockerfile的保留命令</h3><p>官方说明:<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></p>
<table>
<thead>
<tr>
<th>保留字</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><strong>FROM</strong></td>
<td><strong>当前镜像是基于哪个镜像的</strong> <code>第一个指令必须是FROM</code></td>
</tr>
<tr>
<td>MAINTAINER</td>
<td>镜像维护者的姓名和邮箱地址</td>
</tr>
<tr>
<td><strong>RUN</strong></td>
<td><strong>构建镜像时需要运行的指令</strong></td>
</tr>
<tr>
<td><strong>EXPOSE</strong></td>
<td><strong>当前容器对外暴露出的端口号</strong></td>
</tr>
<tr>
<td><strong>WORKDIR</strong></td>
<td><strong>指定在创建容器后，终端默认登录进来的工作目录，一个落脚点</strong></td>
</tr>
<tr>
<td><strong>ENV</strong></td>
<td><strong>用来在构建镜像过程中设置环境变量</strong></td>
</tr>
<tr>
<td><strong>ADD</strong></td>
<td><strong>将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar包</strong></td>
</tr>
<tr>
<td><strong>COPY</strong></td>
<td><strong>类似于ADD，拷贝文件和目录到镜像中</strong>​<strong>将从构建上下文目录中&lt;原路径&gt;的文件&#x2F;目录复制到新的一层的镜像内的&lt;目标路径&gt;位置</strong></td>
</tr>
<tr>
<td><strong>VOLUME</strong></td>
<td><strong>容器数据卷，用于数据保存和持久化工作</strong></td>
</tr>
<tr>
<td><strong>CMD</strong></td>
<td><strong>指定一个容器启动时要运行的命令</strong>​<strong>Dockerfile中可以有多个CMD指令，但只有最后一个生效，CMD会被docker run之后的参数替换</strong></td>
</tr>
<tr>
<td><strong>ENTRYPOINT</strong></td>
<td><strong>指定一个容器启动时要运行的命令</strong>​<strong>ENTRYPOINT的目的和CMD一样，都是在指定容器启动程序及其参数</strong></td>
</tr>
</tbody></table>
<h4 id="FROM-命令"><a href="#FROM-命令" class="headerlink" title="FROM 命令"></a>FROM 命令</h4><ul>
<li><p>基于那个镜像进行构建新的镜像,在构建时会自动从docker hub拉取base镜像 必须作为Dockerfile的第一个指令出现</p>
</li>
<li><p>语法:</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span>  &lt;image&gt;</span><br><span class="line"><span class="keyword">FROM</span>  &lt;image&gt;[:&lt;tag&gt;]     使用版本不写为latest</span><br><span class="line"><span class="keyword">FROM</span>  &lt;image&gt;[@&lt;digest&gt;]  使用摘要</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="MAINTAINER-命令"><a href="#MAINTAINER-命令" class="headerlink" title="MAINTAINER  命令"></a>MAINTAINER  命令</h4><ul>
<li><p>镜像维护者的姓名和邮箱地址[废弃]</p>
</li>
<li><p>语法:</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MAINTAINER</span> &lt;name&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="RUN-命令"><a href="#RUN-命令" class="headerlink" title="RUN 命令"></a>RUN 命令</h4><ul>
<li><p>RUN指令将在当前映像之上的新层中执行任何命令并提交结果。生成的提交映像将用于Dockerfile中的下一步</p>
</li>
<li><p>语法:</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> &lt;<span class="built_in">command</span>&gt; (shell form, the <span class="built_in">command</span> is run <span class="keyword">in</span> a shell, <span class="built_in">which</span> by default is /bin/sh -c on Linux or cmd /S /C on Windows)</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> hello</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> [<span class="string">&quot;executable&quot;</span>, <span class="string">&quot;param1&quot;</span>, <span class="string">&quot;param2&quot;</span>] (<span class="built_in">exec</span> form)</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> [<span class="string">&quot;/bin/bash&quot;</span>, <span class="string">&quot;-c&quot;</span>, <span class="string">&quot;echo hello&quot;</span>]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="EXPOSE-命令"><a href="#EXPOSE-命令" class="headerlink" title="EXPOSE 命令"></a>EXPOSE 命令</h4><ul>
<li><p>用来指定构建的镜像在运行为容器时对外暴露的端口</p>
</li>
<li><p>语法:</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span>/tcp  如果没有显示指定则默认暴露都是tcp</span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span>/udp</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="CMD-命令"><a href="#CMD-命令" class="headerlink" title="CMD 命令"></a>CMD 命令</h4><ul>
<li><p>用来为启动的容器指定执行的命令,在Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。</p>
</li>
<li><p>注意: <strong>Dockerfile中只能有一条CMD指令。如果列出多个命令，则只有最后一个命令才会生效。</strong></p>
</li>
<li><p>语法:</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;executable&quot;</span>,<span class="string">&quot;param1&quot;</span>,<span class="string">&quot;param2&quot;</span>] (<span class="built_in">exec</span> form, this is the preferred form)</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;param1&quot;</span>,<span class="string">&quot;param2&quot;</span>] (as default parameters to ENTRYPOINT)</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> <span class="built_in">command</span> param1 param2 (shell form)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="WORKDIR-命令"><a href="#WORKDIR-命令" class="headerlink" title="WORKDIR 命令"></a>WORKDIR 命令</h4><ul>
<li><p>用来为Dockerfile中的任何RUN、CMD、ENTRYPOINT、COPY和ADD指令设置工作目录。如果WORKDIR不存在，即使它没有在任何后续Dockerfile指令中使用，它也将被创建。</p>
</li>
<li><p>语法:</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /path/to/workdir</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /a</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> b</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> c</span></span><br><span class="line">`注意:<span class="keyword">WORKDIR</span><span class="language-bash">指令可以在Dockerfile中多次使用。如果提供了相对路径，则该路径将与先前WORKDIR指令的路径相对`</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="ENV-命令"><a href="#ENV-命令" class="headerlink" title="ENV 命令"></a>ENV 命令</h4><ul>
<li><p>用来为构建镜像设置环境变量。这个值将出现在构建阶段中所有后续指令的环境中。</p>
</li>
<li><p>语法：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> &lt;key&gt; &lt;value&gt;</span><br><span class="line"><span class="keyword">ENV</span> &lt;key&gt;=&lt;value&gt; ...</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="ADD-命令"><a href="#ADD-命令" class="headerlink" title="ADD 命令"></a>ADD 命令</h4><ul>
<li><p>用来从context上下文复制新文件、目录或远程文件url，并将它们添加到位于指定路径的映像文件系统中。</p>
</li>
<li><p>语法:</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span><span class="language-bash"> hom* /mydir/       通配符添加多个文件</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> hom?.txt /mydir/   通配符添加</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> test.txt relativeDir/  可以指定相对路径</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> test.txt /absoluteDir/ 也可以指定绝对路径</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> url </span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="COPY-命令"><a href="#COPY-命令" class="headerlink" title="COPY 命令"></a>COPY 命令</h4><ul>
<li><p>用来将context目录中指定文件复制到镜像的指定目录中</p>
</li>
<li><p>语法:</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> src dest</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> [<span class="string">&quot;&lt;src&gt;&quot;</span>,... <span class="string">&quot;&lt;dest&gt;&quot;</span>]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="VOLUME-命令"><a href="#VOLUME-命令" class="headerlink" title="VOLUME 命令"></a>VOLUME 命令</h4><ul>
<li><p>用来定义容器运行时可以挂在到宿主机的目录</p>
</li>
<li><p>语法:</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> [<span class="string">&quot;/data&quot;</span>]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="ENTRYPOINT命令"><a href="#ENTRYPOINT命令" class="headerlink" title="ENTRYPOINT命令"></a>ENTRYPOINT命令</h4><ul>
<li><p>用来指定容器启动时执行命令和CMD类似</p>
</li>
<li><p>语法:</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  [<span class="string">&quot;executable&quot;</span>, <span class="string">&quot;param1&quot;</span>, <span class="string">&quot;param2&quot;</span>]</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> <span class="built_in">command</span> param1 param2</span></span><br></pre></td></tr></table></figure>

<p>ENTRYPOINT指令，往往用于设置容器启动后的<strong>第一个命令</strong>，这对一个容器来说往往是固定的。<br>CMD指令，往往用于设置容器启动的第一个命令的<strong>默认参数</strong>，这对一个容器来说可以是变化的。</p>
</li>
</ul>
<h4 id="ENTRYPOINT命令-1"><a href="#ENTRYPOINT命令-1" class="headerlink" title="ENTRYPOINT命令"></a>ENTRYPOINT命令</h4><h3 id="Dockerfile构建springboot项目部署"><a href="#Dockerfile构建springboot项目部署" class="headerlink" title="Dockerfile构建springboot项目部署"></a>Dockerfile构建springboot项目部署</h3><h5 id="准备springboot可运行项目"><a href="#准备springboot可运行项目" class="headerlink" title="准备springboot可运行项目"></a>准备springboot可运行项目</h5><p><img src="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141654171.png" alt="image-20200605172151266"></p>
<h5 id="将可运行项目放入linux虚拟机中"><a href="#将可运行项目放入linux虚拟机中" class="headerlink" title="将可运行项目放入linux虚拟机中"></a>将可运行项目放入linux虚拟机中</h5><p><img src="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141654176.png" alt="image-20200605172340380"></p>
<h5 id="编写Dockerfile"><a href="#编写Dockerfile" class="headerlink" title="编写Dockerfile"></a>编写Dockerfile</h5><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /ems</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> ems.jar /ems</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8989</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-jar&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;ems.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<h5 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ems]# docker build -t ems .</span><br></pre></td></tr></table></figure>

<h5 id="运行镜像"><a href="#运行镜像" class="headerlink" title="运行镜像"></a>运行镜像</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ems]# docker run -p 8989:8989 ems</span><br></pre></td></tr></table></figure>

<h5 id="访问项目"><a href="#访问项目" class="headerlink" title="访问项目"></a>访问项目</h5><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://10.15.0.8:8989/ems/login.html</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141654473.png" alt="image-20200605173141636"></p>
<hr>
<h2 id="高级网络配置"><a href="#高级网络配置" class="headerlink" title="高级网络配置"></a>高级网络配置</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>当 Docker 启动时，会自动在主机上创建一个 <code>docker0</code> 虚拟网桥，实际上是 Linux 的一个 bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。</p>
<p>同时，Docker 随机分配一个本地未占用的私有网段（在 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc1918">RFC1918</a> 中定义）中的一个地址给 <code>docker0</code> 接口。比如典型的 <code>172.17.42.1</code>，掩码为 <code>255.255.0.0</code>。此后启动的容器内的网口也会自动分配一个同一网段（<code>172.17.0.0/16</code>）的地址。</p>
<p>当创建一个 Docker 容器的时候，同时会创建了一对 <code>veth pair</code> 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即 <code>eth0</code>；另一端在本地并被挂载到 <code>docker0</code> 网桥，名称以 <code>veth</code> 开头（例如 <code>vethAQI2QT</code>）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。</p>
<p><img src="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141654542.png" alt="image-20201125105847896"></p>
<h3 id="查看网络信息"><a href="#查看网络信息" class="headerlink" title="查看网络信息"></a>查看网络信息</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># docker network ls</span></span><br></pre></td></tr></table></figure>

<h3 id="创建一个网桥"><a href="#创建一个网桥" class="headerlink" title="创建一个网桥"></a>创建一个网桥</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># docker network create -d bridge 网桥名称</span></span><br></pre></td></tr></table></figure>

<h3 id="删除一个网桥"><a href="#删除一个网桥" class="headerlink" title="删除一个网桥"></a>删除一个网桥</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># docker network rm 网桥名称</span></span><br></pre></td></tr></table></figure>

<h3 id="容器之前使用网络通信"><a href="#容器之前使用网络通信" class="headerlink" title="容器之前使用网络通信"></a>容器之前使用网络通信</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.查询当前网络配置</span></span><br><span class="line"><span class="bullet">-</span> docker network ls</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">8e424e5936b7        bridge              bridge              local</span><br><span class="line">17d974db02da        docker_gwbridge     bridge              local</span><br><span class="line">d6c326e433f7        host                host                local</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 2.创建桥接网络</span></span><br><span class="line"><span class="bullet">-</span> docker network create -d bridge info</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@centos ~]# docker network create -d bridge info</span><br><span class="line">6e4aaebff79b1df43a064e0e8fdab08f52d64ce34db78dd5184ce7aaaf550a2f</span><br><span class="line">[root@centos ~]# docker network ls</span><br><span class="line">NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="line">8e424e5936b7        bridge              bridge              local</span><br><span class="line">17d974db02da        docker_gwbridge     bridge              local</span><br><span class="line">d6c326e433f7        host                host                local</span><br><span class="line">6e4aaebff79b        info                bridge              local</span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 3.启动容器指定使用网桥</span></span><br><span class="line"><span class="bullet">-</span> docker run -d -p 8890:80 --name nginx001 --network info nginx </span><br><span class="line"><span class="bullet">-</span> docker run -d -p 8891:80 --name nginx002 --network info nginx </span><br><span class="line"><span class="code">	`注意:一旦指定网桥后--name指定名字就是主机名,多个容器指定在同一个网桥时,可以在任意一个容器中使用主机名与容器进行互通`</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@centos ~]# docker run -d -p 8890:80 --name nginx001 --network info nginx </span><br><span class="line">c315bcc94e9ddaa36eb6c6f16ca51592b1ac8bf1ecfe9d8f01d892f3f10825fe</span><br><span class="line">[root@centos ~]# docker run -d -p 8891:80 --name nginx002 --network info nginx</span><br><span class="line">f8682db35dd7fb4395f90edb38df7cad71bbfaba71b6a4c6e2a3a525cb73c2a5</span><br><span class="line">[root@centos ~]# docker ps</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES</span><br><span class="line">f8682db35dd7        nginx               &quot;/docker-entrypoint.…&quot;   3 seconds ago       Up 2 seconds        0.0.0.0:8891-&gt;80/tcp   nginx002</span><br><span class="line">c315bcc94e9d        nginx               &quot;/docker-entrypoint.…&quot;   7 minutes ago       Up 7 minutes        0.0.0.0:8890-&gt;80/tcp   nginx001</span><br><span class="line">b63169d43792        mysql:5.7.19        &quot;docker-entrypoint.s…&quot;   7 minutes ago       Up 7 minutes        3306/tcp               mysql_mysql.1.s75qe5kkpwwttyf0wrjvd2cda</span><br><span class="line">[root@centos ~]# docker exec -it f8682db35dd7 /bin/bash</span><br><span class="line">root@f8682db35dd7:/# curl http://nginx001</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</span><br><span class="line">.....</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="高级数据卷配置"><a href="#高级数据卷配置" class="headerlink" title="高级数据卷配置"></a>高级数据卷配置</h2><h3 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h3><p><code>数据卷</code> 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：</p>
<ul>
<li><code>数据卷</code> 可以在容器之间共享和重用</li>
<li>对 <code>数据卷</code> 的修改会立马生效</li>
<li>对 <code>数据卷</code> 的更新，不会影响镜像</li>
<li><code>数据卷</code> 默认会一直存在，即使容器被删除</li>
</ul>
<blockquote>
<p>注意：<code>数据卷</code> 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。</p>
</blockquote>
<h3 id="创建数据卷"><a href="#创建数据卷" class="headerlink" title="创建数据卷"></a>创建数据卷</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@centos ~]# docker volume create my-vol</span><br><span class="line">my-vol</span><br></pre></td></tr></table></figure>

<h3 id="查看数据卷"><a href="#查看数据卷" class="headerlink" title="查看数据卷"></a>查看数据卷</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@centos ~]# docker volume inspect my-vol       </span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;CreatedAt&quot;: &quot;2020-11-25T11:43:56+08:00&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;my-vol&quot;,</span><br><span class="line">        &quot;Options&quot;: &#123;&#125;,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="挂载数据卷"><a href="#挂载数据卷" class="headerlink" title="挂载数据卷"></a>挂载数据卷</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@centos ~]# docker run -d -P --name web  -v my-vol:/usr/share/nginx/html  nginx</span><br><span class="line">[root@centos ~]# docker inspect web</span><br><span class="line">				&quot;Mounts&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;volume&quot;,</span><br><span class="line">                &quot;Name&quot;: &quot;my-vol&quot;,</span><br><span class="line">                &quot;Source&quot;: &quot;/var/lib/docker/volumes/my-vol/_data&quot;,</span><br><span class="line">                &quot;Destination&quot;: &quot;/usr/share/nginx/html&quot;,</span><br><span class="line">                &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">                &quot;Mode&quot;: &quot;z&quot;,</span><br><span class="line">                &quot;RW&quot;: true,</span><br><span class="line">                &quot;Propagation&quot;: &quot;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br></pre></td></tr></table></figure>

<h3 id="删除数据卷"><a href="#删除数据卷" class="headerlink" title="删除数据卷"></a>删除数据卷</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume rm my-vol</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>Compose</code> 项目是 Docker 官方的开源项目，负责实现对 Docker 容器集群的快速编排。从功能上看，跟 <code>OpenStack</code> 中的 <code>Heat</code> 十分类似。</p>
<p>其代码目前在 <a target="_blank" rel="noopener" href="https://github.com/docker/compose">https://github.com/docker/compose</a> 上开源。</p>
<p><code>Compose</code> 定位是 「定义和运行多个 Docker 容器的应用（Defining and running multi-container Docker applications）」，其前身是开源项目 Fig。</p>
<p>通过第一部分中的介绍，我们知道使用一个 <code>Dockerfile</code> 模板文件，可以让用户很方便的定义一个单独的应用容器。然而，在日常工作中，经常会碰到需要多个容器相互配合来完成某项任务的情况。例如要实现一个 Web 项目，除了 Web 服务容器本身，往往还需要再加上后端的数据库服务容器，甚至还包括负载均衡容器等。</p>
<p><code>Compose</code> 恰好满足了这样的需求。它允许用户通过一个单独的 <code>docker-compose.yml</code> 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）。</p>
<p><code>Compose</code> 中有两个重要的概念：</p>
<ul>
<li>服务 (<code>service</code>)：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</li>
<li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元，在 <code>docker-compose.yml</code> 文件中定义。</li>
</ul>
<p><code>Compose</code> 的默认管理对象是项目，通过子命令对项目中的一组容器进行便捷地生命周期管理。</p>
<p><code>Compose</code> 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 <code>Compose</code> 来进行编排管理。</p>
<h3 id="安装与卸载"><a href="#安装与卸载" class="headerlink" title="安装与卸载"></a>安装与卸载</h3><h6 id="1-linux"><a href="#1-linux" class="headerlink" title="1.linux"></a>1.linux</h6><ul>
<li>在 Linux 上的也安装十分简单，从 官方 GitHub Release 处直接下载编译好的二进制文件即可。例如，在 Linux 64 位系统上直接下载对应的二进制包。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo curl -L https://github.com/docker/compose/releases/download/1.25.5/docker-compose-`<span class="built_in">uname</span> -s`-`<span class="built_in">uname</span> -m` &gt; /usr/local/bin/docker-compose</span><br><span class="line">$ sudo <span class="built_in">chmod</span> +x /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>

<h6 id="2-macos、window"><a href="#2-macos、window" class="headerlink" title="2.macos、window"></a>2.macos、window</h6><ul>
<li>Compose 可以通过 Python 的包管理工具 pip 进行安装，也可以直接下载编译好的二进制文件使用，甚至能够直接在 Docker 容器中运行。<code>Docker Desktop for Mac/Windows 自带 docker-compose 二进制文件，安装 Docker 之后可以直接使用</code>。</li>
</ul>
<h6 id="3-bash命令补全"><a href="#3-bash命令补全" class="headerlink" title="3.bash命令补全"></a>3.bash命令补全</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl -L https://raw.githubusercontent.com/docker/compose/1.25.5/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose</span></span><br></pre></td></tr></table></figure>

<h6 id="4-卸载"><a href="#4-卸载" class="headerlink" title="4.卸载"></a>4.卸载</h6><ul>
<li>如果是二进制包方式安装的，删除二进制文件即可。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo <span class="built_in">rm</span> /usr/local/bin/docker-compose</span></span><br></pre></td></tr></table></figure>

<h6 id="5-测试安装成功"><a href="#5-测试安装成功" class="headerlink" title="5.测试安装成功"></a>5.测试安装成功</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker-compose --version</span></span><br><span class="line"> docker-compose version 1.25.5, build 4667896b</span><br></pre></td></tr></table></figure>

<h3 id="docker-compose使用"><a href="#docker-compose使用" class="headerlink" title="docker compose使用"></a>docker compose使用</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.相关概念</span></span><br></pre></td></tr></table></figure>

<p>首先介绍几个术语。</p>
<ul>
<li>服务 (<code>service</code>)：一个应用容器，实际上可以运行多个相同镜像的实例。</li>
<li>项目 (<code>project</code>)：由一组关联的应用容器组成的一个完整业务单元。∂一个项目可以由多个服务（容器）关联而成，<code>Compose</code> 面向项目进行管理。</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 2.场景</span></span><br></pre></td></tr></table></figure>

<p>最常见的项目是 web 网站，该项目应该包含 web 应用和缓存。</p>
<ul>
<li>springboot应用</li>
<li>mysql服务</li>
<li>redis服务</li>
<li>elasticsearch服务</li>
<li>…….</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 3.docker-compose模板</span></span><br><span class="line"><span class="bullet">-</span> 参考文档:https://docker<span class="emphasis">_practice.gitee.io/zh-cn/compose/compose_</span>file.html</span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.0&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mysqldb:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:5.7.19</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/root/mysql/conf:/etc/mysql/conf.d</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/root/mysql/logs:/logs</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/root/mysql/data:/var/lib/mysql</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ems</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:4.0.14</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6379:6379&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ems</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/root/redis/data:/data</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">redis-server</span></span><br><span class="line">    </span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">ems:</span></span><br></pre></td></tr></table></figure>

<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 4.通过docker-compose运行一组容器</span></span><br><span class="line"><span class="bullet">-</span> 参考文档:https://docker<span class="emphasis">_practice.gitee.io/zh-cn/compose/commands.html</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@centos ~]<span class="comment"># docker-compose up    							//前台启动一组服务</span></span><br><span class="line">[root@centos ~]<span class="comment"># docker-compose up -d 							//后台启动一组服务</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="docker-compose-模板文件"><a href="#docker-compose-模板文件" class="headerlink" title="docker-compose 模板文件"></a>docker-compose 模板文件</h3><p>模板文件是使用 <code>Compose</code> 的核心，涉及到的指令关键字也比较多。但大家不用担心，这里面大部分指令跟 <code>docker run</code> 相关参数的含义都是类似的。</p>
<p>默认的模板文件名称为 <code>docker-compose.yml</code>，格式为 YAML 格式。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">webapp:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">examples/web</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;80:80&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;/data&quot;</span></span><br></pre></td></tr></table></figure>

<p>注意每个服务都必须通过 <code>image</code> 指令指定镜像或 <code>build</code> 指令（需要 Dockerfile）等来自动构建生成镜像。</p>
<p>如果使用 <code>build</code> 指令，在 <code>Dockerfile</code> 中设置的选项(例如：<code>CMD</code>, <code>EXPOSE</code>, <code>VOLUME</code>, <code>ENV</code> 等) 将会自动被获取，无需在 <code>docker-compose.yml</code> 中重复设置。</p>
<p>下面分别介绍各个指令的用法。</p>
<h4 id="build"><a href="#build" class="headerlink" title="build"></a><code>build</code></h4><p>指定 <code>Dockerfile</code> 所在文件夹的路径（可以是绝对路径，或者相对 docker-compose.yml 文件的路径）。 <code>Compose</code> 将会利用它自动构建这个镜像，然后使用这个镜像。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">webapp:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">./dir</span></span><br></pre></td></tr></table></figure>

<p>你也可以使用 <code>context</code> 指令指定 <code>Dockerfile</code> 所在文件夹的路径。</p>
<p>使用 <code>dockerfile</code> 指令指定 <code>Dockerfile</code> 文件名。</p>
<p>使用 <code>arg</code> 指令指定构建镜像时的变量。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">webapp:</span></span><br><span class="line">    <span class="attr">build:</span></span><br><span class="line">      <span class="attr">context:</span> <span class="string">./dir</span></span><br><span class="line">      <span class="attr">dockerfile:</span> <span class="string">Dockerfile-alternate</span></span><br><span class="line">      <span class="attr">args:</span></span><br><span class="line">        <span class="attr">buildno:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="command"><a href="#command" class="headerlink" title="command"></a><code>command</code></h4><p>覆盖容器启动后默认执行的命令。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">command:</span> <span class="string">echo</span> <span class="string">&quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a><code>container_name</code></h4><p>指定容器名称。默认将会使用 <code>项目名称_服务名称_序号</code> 这样的格式。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">container_name:</span> <span class="string">docker-web-container</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意: 指定容器名称后，该服务将无法进行扩展（scale），因为 Docker 不允许多个容器具有相同的名称。</p>
</blockquote>
<h4 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a><code>depends_on</code></h4><p>解决容器的依赖、启动先后的问题。以下例子中会先启动 <code>redis</code> <code>db</code> 再启动 <code>web</code></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">web:</span></span><br><span class="line">    <span class="attr">build:</span> <span class="string">.</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">db</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">db:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">postgres</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：<code>web</code> 服务不会等待 <code>redis</code> <code>db</code> 「完全启动」之后才启动。</p>
</blockquote>
<h4 id="env-file"><a href="#env-file" class="headerlink" title="env_file"></a><code>env_file</code></h4><p>从文件中获取环境变量，可以为单独的文件路径或列表。</p>
<p>如果通过 <code>docker-compose -f FILE</code> 方式来指定 Compose 模板文件，则 <code>env_file</code> 中变量的路径会基于模板文件路径。</p>
<p>如果有变量名称与 <code>environment</code> 指令冲突，则按照惯例，以后者为准。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">env_file: .<span class="built_in">env</span></span><br><span class="line"></span><br><span class="line">env_file:</span><br><span class="line">  - ./common.env</span><br><span class="line">  - ./apps/web.env</span><br><span class="line">  - /opt/secrets.env</span><br></pre></td></tr></table></figure>

<p>环境变量文件中每一行必须符合格式，支持 <code>#</code> 开头的注释行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># common.env: Set development environment</span></span><br><span class="line">PROG_ENV=development</span><br></pre></td></tr></table></figure>

<h4 id="environment"><a href="#environment" class="headerlink" title="environment"></a><code>environment</code></h4><p>设置环境变量。你可以使用数组或字典两种格式。</p>
<p>只给定名称的变量会自动获取运行 Compose 主机上对应变量的值，可以用来防止泄露不必要的数据。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">environment:</span></span><br><span class="line">  <span class="attr">RACK_ENV:</span> <span class="string">development</span></span><br><span class="line">  <span class="attr">SESSION_SECRET:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">environment:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">RACK_ENV=development</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">SESSION_SECRET</span></span><br></pre></td></tr></table></figure>

<p>如果变量名称或者值中用到 <code>true|false，yes|no</code> 等表达 <a target="_blank" rel="noopener" href="https://yaml.org/type/bool.html">布尔</a> 含义的词汇，最好放到引号里，避免 YAML 自动解析某些内容为对应的布尔语义。这些特定词汇，包括</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y|Y|<span class="built_in">yes</span>|Yes|YES|n|N|no|No|NO|<span class="literal">true</span>|True|TRUE|<span class="literal">false</span>|False|FALSE|on|On|ON|off|Off|OFF</span><br></pre></td></tr></table></figure>

<h4 id="healthcheck"><a href="#healthcheck" class="headerlink" title="healthcheck"></a><code>healthcheck</code></h4><p>通过命令检查容器是否健康运行。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">healthcheck:</span></span><br><span class="line">  <span class="attr">test:</span> [<span class="string">&quot;CMD&quot;</span>, <span class="string">&quot;curl&quot;</span>, <span class="string">&quot;-f&quot;</span>, <span class="string">&quot;http://localhost&quot;</span>]</span><br><span class="line">  <span class="attr">interval:</span> <span class="string">1m30s</span></span><br><span class="line">  <span class="attr">timeout:</span> <span class="string">10s</span></span><br><span class="line">  <span class="attr">retries:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h4 id="image"><a href="#image" class="headerlink" title="image"></a><code>image</code></h4><p>指定为镜像名称或镜像 ID。如果镜像在本地不存在，<code>Compose</code> 将会尝试拉取这个镜像。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">image:</span> <span class="string">ubuntu</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">orchardup/postgresql</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">a4bc65fd</span></span><br></pre></td></tr></table></figure>

<h4 id="networks"><a href="#networks" class="headerlink" title="networks"></a><code>networks</code></h4><p>配置容器连接的网络。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">some-service:</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">some-network</span></span><br><span class="line">     <span class="bullet">-</span> <span class="string">other-network</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span></span><br><span class="line">  <span class="attr">some-network:</span></span><br><span class="line">  <span class="attr">other-network:</span></span><br></pre></td></tr></table></figure>

<h4 id="ports"><a href="#ports" class="headerlink" title="ports"></a><code>ports</code></h4><p>暴露端口信息。</p>
<p>使用宿主端口：容器端口 <code>(HOST:CONTAINER)</code> 格式，或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ports:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&quot;3000&quot;</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&quot;8000:8000&quot;</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&quot;49100:22&quot;</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">&quot;127.0.0.1:8001:8001&quot;</span></span><br></pre></td></tr></table></figure>

<p>*注意：当使用 <em>​</em><code>HOST:CONTAINER</code>*​ * 格式来映射端口时，如果你使用的容器端口小于 60 并且没放到引号里，可能会得到错误结果，因为 <em>​</em><code>YAML</code>*​ * 会自动解析 <em>​</em><code>xx:yy</code><em>​ * 这种数字格式为 60 进制。为避免出现这种问题，建议数字串都采用引号包括起来的字符串格式。</em></p>
<h4 id="sysctls"><a href="#sysctls" class="headerlink" title="sysctls"></a><code>sysctls</code></h4><p>配置容器内核参数。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sysctls:</span></span><br><span class="line">  <span class="attr">net.core.somaxconn:</span> <span class="number">1024</span></span><br><span class="line">  <span class="attr">net.ipv4.tcp_syncookies:</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="attr">sysctls:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">net.core.somaxconn=1024</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">net.ipv4.tcp_syncookies=0</span></span><br></pre></td></tr></table></figure>

<h4 id="ulimits"><a href="#ulimits" class="headerlink" title="ulimits"></a><code>ulimits</code></h4><p>指定容器的 ulimits 限制值。</p>
<p>例如，指定最大进程数为 65535，指定文件句柄数为 20000（软限制，应用可以随时修改，不能超过硬限制） 和 40000（系统硬限制，只能 root 用户提高）。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ulimits:</span></span><br><span class="line">  <span class="attr">nproc:</span> <span class="number">65535</span></span><br><span class="line">  <span class="attr">nofile:</span></span><br><span class="line">    <span class="attr">soft:</span> <span class="number">20000</span></span><br><span class="line">    <span class="attr">hard:</span> <span class="number">40000</span></span><br></pre></td></tr></table></figure>

<h4 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a><code>volumes</code></h4><p>数据卷所挂载路径设置。可以设置为宿主机路径(<code>HOST:CONTAINER</code>)或者数据卷名称(<code>VOLUME:CONTAINER</code>)，并且可以设置访问模式 （<code>HOST:CONTAINER:ro</code>）。</p>
<p>该指令中路径支持相对路径。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">/var/lib/mysql</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">cache/:/tmp/cache</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">~/configs:/etc/configs/:ro</span></span><br></pre></td></tr></table></figure>

<p>如果路径为数据卷名称，必须在文件中配置数据卷。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">my_src:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql:8.0</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">mysql_data:/var/lib/mysql</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">mysql_data:</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="docker-compose-常用命令"><a href="#docker-compose-常用命令" class="headerlink" title="docker-compose 常用命令"></a>docker-compose 常用命令</h3><h5 id="1-命令对象与格式"><a href="#1-命令对象与格式" class="headerlink" title="1. 命令对象与格式"></a>1. 命令对象与格式</h5><p>对于 Compose 来说，大部分命令的对象既可以是项目本身，也可以指定为项目中的服务或者容器。如果没有特别的说明，命令对象将是项目，这意味着项目中所有的服务都会受到命令影响。</p>
<p>执行 <code>docker-compose [COMMAND] --help</code> 或者 <code>docker-compose help [COMMAND]</code> 可以查看具体某个命令的使用格式。</p>
<p><code>docker-compose</code> 命令的基本的使用格式是</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose [-f=&lt;arg&gt;...] [options] [COMMAND] [ARGS...]</span><br></pre></td></tr></table></figure>

<h5 id="2-命令选项"><a href="#2-命令选项" class="headerlink" title="2. 命令选项"></a>2. 命令选项</h5><ul>
<li><code>-f, --file FILE</code> 指定使用的 Compose 模板文件，默认为 <code>docker-compose.yml</code>，可以多次指定。</li>
<li><code>-p, --project-name NAME</code> 指定项目名称，默认将使用所在目录名称作为项目名。</li>
<li><code>--x-networking</code> 使用 Docker 的可拔插网络后端特性</li>
<li><code>--x-network-driver DRIVER</code> 指定网络后端的驱动，默认为 <code>bridge</code></li>
<li><code>--verbose</code> 输出更多调试信息。</li>
<li><code>-v, --version</code> 打印版本并退出。</li>
</ul>
<h5 id="3-命令使用说明"><a href="#3-命令使用说明" class="headerlink" title="3.命令使用说明"></a>3.命令使用说明</h5><h5 id="up"><a href="#up" class="headerlink" title="up"></a><code>up</code></h5><p>格式为 <code>docker-compose up [options] [SERVICE...]</code>。</p>
<ul>
<li>该命令十分强大，它将尝试自动完成包括构建镜像，（重新）创建服务，启动服务，并关联服务相关容器的一系列操作。</li>
<li>链接的服务都将会被自动启动，除非已经处于运行状态。</li>
<li>可以说，大部分时候都可以直接通过该命令来启动一个项目。</li>
<li>默认情况，<code>docker-compose up</code> 启动的容器都在前台，控制台将会同时打印所有容器的输出信息，可以很方便进行调试。</li>
<li>当通过 <code>Ctrl-C</code> 停止命令时，所有容器将会停止。</li>
<li>如果使用 <code>docker-compose up -d</code>，将会在后台启动并运行所有的容器。一般推荐生产环境下使用该选项。</li>
<li>默认情况，如果服务容器已经存在，<code>docker-compose up</code> 将会尝试停止容器，然后重新创建（保持使用 <code>volumes-from</code> 挂载的卷），以保证新启动的服务匹配 <code>docker-compose.yml</code> 文件的最新内容</li>
</ul>
<hr>
<h5 id="down"><a href="#down" class="headerlink" title="down"></a><code>down</code></h5><ul>
<li>此命令将会停止 <code>up</code> 命令所启动的容器，并移除网络</li>
</ul>
<hr>
<h5 id="exec"><a href="#exec" class="headerlink" title="exec"></a><code>exec</code></h5><ul>
<li>进入指定的容器。</li>
</ul>
<hr>
<h5 id="ps"><a href="#ps" class="headerlink" title="ps"></a><code>ps</code></h5><p>格式为 <code>docker-compose ps [options] [SERVICE...]</code>。</p>
<p>列出项目中目前的所有容器。</p>
<p>选项：</p>
<ul>
<li><code>-q</code> 只打印容器的 ID 信息。</li>
</ul>
<hr>
<h5 id="restart"><a href="#restart" class="headerlink" title="restart"></a><code>restart</code></h5><p>格式为 <code>docker-compose restart [options] [SERVICE...]</code>。</p>
<p>重启项目中的服务。</p>
<p>选项：</p>
<ul>
<li><code>-t, --timeout TIMEOUT</code> 指定重启前停止容器的超时（默认为 10 秒）。</li>
</ul>
<hr>
<h5 id="rm"><a href="#rm" class="headerlink" title="rm"></a><code>rm</code></h5><p>格式为 <code>docker-compose rm [options] [SERVICE...]</code>。</p>
<p>删除所有（停止状态的）服务容器。推荐先执行 <code>docker-compose stop</code> 命令来停止容器。</p>
<p>选项：</p>
<ul>
<li><code>-f, --force</code> 强制直接删除，包括非停止状态的容器。一般尽量不要使用该选项。</li>
<li><code>-v</code> 删除容器所挂载的数据卷。</li>
</ul>
<hr>
<h5 id="start"><a href="#start" class="headerlink" title="start"></a><code>start</code></h5><p>格式为 <code>docker-compose start [SERVICE...]</code>。</p>
<p>启动已经存在的服务容器。</p>
<hr>
<h5 id="stop"><a href="#stop" class="headerlink" title="stop"></a><code>stop</code></h5><p>格式为 <code>docker-compose stop [options] [SERVICE...]</code>。</p>
<p>停止已经处于运行状态的容器，但不删除它。通过 <code>docker-compose start</code> 可以再次启动这些容器。</p>
<p>选项：</p>
<ul>
<li><code>-t, --timeout TIMEOUT</code> 停止容器时候的超时（默认为 10 秒）。</li>
</ul>
<hr>
<h5 id="top"><a href="#top" class="headerlink" title="top"></a><code>top</code></h5><p>查看各个服务容器内运行的进程。</p>
<hr>
<h5 id="unpause"><a href="#unpause" class="headerlink" title="unpause"></a><code>unpause</code></h5><p>格式为 <code>docker-compose unpause [SERVICE...]</code>。</p>
<p>恢复处于暂停状态中的服务。</p>
<hr>
<h2 id="可视化管理工具"><a href="#可视化管理工具" class="headerlink" title="可视化管理工具"></a>可视化管理工具</h2><h4 id="安装Portainer"><a href="#安装Portainer" class="headerlink" title="安装Portainer"></a>安装Portainer</h4><p>官方安装说明：<a target="_blank" rel="noopener" href="http://www.yunweipai.com/go?_=8fe4813824aHR0cHM6Ly93d3cucG9ydGFpbmVyLmlvL2luc3RhbGxhdGlvbi8=">https://www.portainer.io/installation/</a></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@ubuntu1804 ~]#docker pull  portainer/portainer</span><br><span class="line"></span><br><span class="line">[root@ubuntu1804 ~]#docker volume create portainer_data</span><br><span class="line">portainer_data</span><br><span class="line">[root@ubuntu1804 ~]#docker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer</span><br><span class="line">20db26b67b791648c2ef6aee444a5226a9c897ebcf0160050e722dbf4a4906e3</span><br><span class="line">[root@ubuntu1804 ~]#docker ps </span><br><span class="line">CONTAINER ID        IMAGE                 COMMAND             CREATED             STATUS              PORTS                                            NAMES</span><br><span class="line">20db26b67b79        portainer/portainer   &quot;/portainer&quot;        5 seconds ago       Up 4 seconds        0.0.0.0:8000-&gt;8000/tcp, 0.0.0.0:9000-&gt;9000/tcp   portainer</span><br></pre></td></tr></table></figure>

<h4 id="登录和使用Portainer"><a href="#登录和使用Portainer" class="headerlink" title="登录和使用Portainer"></a>登录和使用Portainer</h4><blockquote>
<p>用浏览器访问：<code>http://localhost:9000</code></p>
</blockquote>
<p>​<img src="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141654476.png" alt="image-20201223231707738"></p>
<h4 id="使用过程…"><a href="#使用过程…" class="headerlink" title="使用过程…"></a>使用过程…</h4><hr>
<h1 id="Docker-核心原理"><a href="#Docker-核心原理" class="headerlink" title="Docker 核心原理"></a>Docker 核心原理</h1><p>从表层来看docker的组成部分是由：仓库、镜像、容器三个部分组成，这是基础层面的体现</p>
<p>犹如MySQL事务的特性：ACID（原子性、一致性、隔离性、持久性）但是维持ACID背后的机制&#x2F;原理是什么？</p>
<p>答：</p>
<ul>
<li>持久性是通过 redo log （重做日志）来保证的；</li>
<li>原子性是通过 undo log（回滚日志） 来保证的；</li>
<li>隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；</li>
<li>一致性则是通过持久性+原子性+隔离性来保证；</li>
</ul>
<p>那么类推docker的三个组成部分或者三个核心概念背后的三个原理是什么支持的？</p>
<p>答：Namespace、Cgroups、rootfs。</p>
<p>（联想：既然docker中的技术是参考Linux内核实现的，那么这其中究竟有多少联系？）</p>
<ul>
<li><p>Namespace，做隔离，让进程只能看到Namespace中的世界；</p>
</li>
<li><p>Cgroups，做限制，让这个“世界”围着一个看不见的墙。</p>
</li>
<li><p>rootfs，做文件系统，rootfs 只是一个操作系统所包含的文件、配置和目录，并不包括操作系统内核。</p>
</li>
</ul>
<blockquote>
<p>注意此处 Linux Namespace 不要和 k8s Namespace 概念混淆：</p>
<p>Linux Namespace 机制：用于资源和视图隔离，使宿主机看不到容器内的资源，容器也看不到其他容器内的资源，实现不同应用的视图隔离，避免干扰</p>
<p>k8s Namespace 机制：就是用户资源的隔离，为了便于管理 k8s 自身的资源</p>
</blockquote>
<p><strong>Namespace</strong>本质就是一个障眼法，进入容器后ps看到不同的pid，其实就是namespace的幻化，本质上容器就是一个运行的进程，其它的进程实际是pid为1的子进程，namespace提供了许多种的障眼法。</p>
<p><img src="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311141654677.png" alt="image">​</p>
<p>namespace本质是怎么建立的？</p>
<p>每一次创建容器的时候本质是Linux系统的fork的调用，在fork调用时会传入一些参数，这个会对Linux内核进行控制生成新的namespace</p>
<hr>
<p>rootfs本质是根文件系统，挂载在容器根目录上，为容器提供隔离后执行环境的文件系统，即容器镜像。</p>
<p>容器的rootfs由三部分组成，1：只读层、2：可读写层、3：init层</p>
<ol>
<li><p>只读层:都以增量的方式分别包含了操作系统的一部分。</p>
</li>
<li><p>可读写：就是专门用来存放你修改 rootfs 后产生的增量，无论是增、删、改，都发生在这里。而当我们使用完了这个被修改过的容器之后，还可以使用 docker commit 和 push 指令，保存这个被修改过的可读写层，并上传到 Docker Hub 上，供其他人使用；而与此同时，原先的只读层里的内容则不会有任何变化。这，就是增量 rootfs 的好处。</p>
</li>
<li><p>Init 层：是 Docker 项目单独生成的一个内部层，专门用来存放 &#x2F;etc&#x2F;hosts、&#x2F;etc&#x2F;resolv.conf 等信息。</p>
</li>
</ol>
<hr>
<p>Cgroups</p>
<p>虽然容器内的第 1 号进程在“障眼法”的干扰下只能看到容器里的情况，但是宿主机上，它作为第 100 号进程与其他所有进程之间依然是平等的竞争关系。这就意味着，虽然第 100 号进程表面上被隔离了起来，但是它所能够使用到的资源（比如 CPU、内存），却是可以随时被宿主机上的其他进程（或者其他容器）占用的。当然，这个 100 号进程自己也可能把所有资源吃光。这些情况，显然都不是一个“沙盒”应该表现出来的合理行为。</p>
<p>而 Linux Cgroups 就是 Linux 内核中用来为进程设置资源限制的一个重要功能。</p>
<p>Linux Cgroups 的全称是 Linux Control Group。它最主要的作用，就是限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等。此外，Cgroups 还能够对进程进行优先级设置、审计，以及将进程挂起和恢复等操作。  </p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_24433609/article/details/128923171">容器基础之三大基石</a></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Docker一文通览</p><p><a href="https://luommy.github.io/post/docker-z1rrgi5.html">https://luommy.github.io/post/docker-z1rrgi5.html</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>luommy</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2023-11-14</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-11-14</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/docker/">docker</a></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/" alt="微信"></span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/" alt="支付宝"></span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>爱发电</span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/post/golang-test-related-mbnma.html"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Golang测试</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/post/20231021-saturday-z1vmbxc.html"><span class="level-item"> </span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="waline-thread"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@waline/client@2.6.3/dist/waline.css"><script src="https://cdn.jsdelivr.net/npm/@waline/client@2.6.3/dist/waline.js"></script><script>Waline.init({
            el: '#waline-thread',
            serverURL: "https://myblog-vercel.vercel.app/",
            path: window.location.pathname,
            lang: "zh-CN",
            
            emoji: ["https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo"],
            dark: "auto",
            meta: ["nick","mail","link"],
            requiredMeta: [],
            login: "disable",
            
            pageSize: 10,
            imageUploader: false,
            highlighter: false,
            texRenderer: false,
            search: false,
            pageview: false,
            comment: false,
            copyright: true,
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Docker通览"><span class="level-left"><span class="level-item">1</span><span class="level-item">Docker通览</span></span></a></li><li><a class="level is-mobile" href="#Docker基础与应用"><span class="level-left"><span class="level-item">2</span><span class="level-item">Docker基础与应用</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#什么是-Docker"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">什么是 Docker</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#官方定义"><span class="level-left"><span class="level-item">2.1.1</span><span class="level-item">官方定义</span></span></a></li><li><a class="level is-mobile" href="#Docker的起源"><span class="level-left"><span class="level-item">2.1.2</span><span class="level-item">Docker的起源</span></span></a></li></ul></li><li><a class="level is-mobile" href="#为什么是Docker"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">为什么是Docker</span></span></a></li><li><a class="level is-mobile" href="#Docker和虚拟机区别"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">Docker和虚拟机区别</span></span></a></li><li><a class="level is-mobile" href="#Docker的安装"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">Docker的安装</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#安装docker-centos7-x"><span class="level-left"><span class="level-item">2.4.1</span><span class="level-item">安装docker(centos7.x)</span></span></a></li><li><a class="level is-mobile" href="#bash安装-通用所有平台"><span class="level-left"><span class="level-item">2.4.2</span><span class="level-item">bash安装(通用所有平台)</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Docker-的核心架构"><span class="level-left"><span class="level-item">2.5</span><span class="level-item">Docker 的核心架构</span></span></a></li><li><a class="level is-mobile" href="#Docker-配置阿里镜像加速服务"><span class="level-left"><span class="level-item">2.6</span><span class="level-item">Docker 配置阿里镜像加速服务</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#docker-运行流程"><span class="level-left"><span class="level-item">2.6.1</span><span class="level-item">docker 运行流程</span></span></a></li><li><a class="level is-mobile" href="#docker配置阿里云镜像加速"><span class="level-left"><span class="level-item">2.6.2</span><span class="level-item">docker配置阿里云镜像加速</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Docker的入门应用"><span class="level-left"><span class="level-item">2.7</span><span class="level-item">Docker的入门应用</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#docker-的第一个程序"><span class="level-left"><span class="level-item">2.7.1</span><span class="level-item">docker 的第一个程序</span></span></a></li></ul></li><li><a class="level is-mobile" href="#常用命令"><span class="level-left"><span class="level-item">2.8</span><span class="level-item">常用命令</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#启动命令"><span class="level-left"><span class="level-item">2.8.1</span><span class="level-item">启动命令</span></span></a></li><li><a class="level is-mobile" href="#辅助命令"><span class="level-left"><span class="level-item">2.8.2</span><span class="level-item">辅助命令</span></span></a></li><li><a class="level is-mobile" href="#Images-镜像命令"><span class="level-left"><span class="level-item">2.8.3</span><span class="level-item">Images 镜像命令</span></span></a></li><li><a class="level is-mobile" href="#Contrainer-容器命令"><span class="level-left"><span class="level-item">2.8.4</span><span class="level-item">Contrainer 容器命令</span></span></a></li></ul></li><li><a class="level is-mobile" href="#docker的镜像原理"><span class="level-left"><span class="level-item">2.9</span><span class="level-item">docker的镜像原理</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#镜像是什么？"><span class="level-left"><span class="level-item">2.9.1</span><span class="level-item">镜像是什么？</span></span></a></li><li><a class="level is-mobile" href="#为什么一个镜像会那么大？"><span class="level-left"><span class="level-item">2.9.2</span><span class="level-item">为什么一个镜像会那么大？</span></span></a></li><li><a class="level is-mobile" href="#Docker镜像原理"><span class="level-left"><span class="level-item">2.9.3</span><span class="level-item">Docker镜像原理</span></span></a></li><li><a class="level is-mobile" href="#为什么docker镜像要采用这种分层结构呢"><span class="level-left"><span class="level-item">2.9.4</span><span class="level-item">为什么docker镜像要采用这种分层结构呢?</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Docker安装常用服务"><span class="level-left"><span class="level-item">2.10</span><span class="level-item">Docker安装常用服务</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#安装mysql"><span class="level-left"><span class="level-item">2.10.1</span><span class="level-item">安装mysql</span></span></a></li><li><a class="level is-mobile" href="#安装Redis服务"><span class="level-left"><span class="level-item">2.10.2</span><span class="level-item">安装Redis服务</span></span></a></li><li><a class="level is-mobile" href="#安装Nginx"><span class="level-left"><span class="level-item">2.10.3</span><span class="level-item">安装Nginx</span></span></a></li><li><a class="level is-mobile" href="#安装Tomcat"><span class="level-left"><span class="level-item">2.10.4</span><span class="level-item">安装Tomcat</span></span></a></li><li><a class="level is-mobile" href="#安装MongoDB数据库"><span class="level-left"><span class="level-item">2.10.5</span><span class="level-item">安装MongoDB数据库</span></span></a></li><li><a class="level is-mobile" href="#安装ElasticSearch"><span class="level-left"><span class="level-item">2.10.6</span><span class="level-item">安装ElasticSearch</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#拉取镜像运行elasticsearch"><span class="level-left"><span class="level-item">2.10.6.1</span><span class="level-item">拉取镜像运行elasticsearch</span></span></a></li><li><a class="level is-mobile" href="#预先配置"><span class="level-left"><span class="level-item">2.10.6.2</span><span class="level-item">预先配置</span></span></a></li><li><a class="level is-mobile" href="#启动EleasticSearch容器"><span class="level-left"><span class="level-item">2.10.6.3</span><span class="level-item">启动EleasticSearch容器</span></span></a></li><li><a class="level is-mobile" href="#安装IK分词器"><span class="level-left"><span class="level-item">2.10.6.4</span><span class="level-item">安装IK分词器</span></span></a></li><li><a class="level is-mobile" href="#安装Kibana"><span class="level-left"><span class="level-item">2.10.6.5</span><span class="level-item">安装Kibana</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#Docker中出现如下错误解决方案"><span class="level-left"><span class="level-item">2.11</span><span class="level-item">Docker中出现如下错误解决方案</span></span></a></li><li><a class="level is-mobile" href="#Dockerfile"><span class="level-left"><span class="level-item">2.12</span><span class="level-item">Dockerfile</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#什么是Dockerfile"><span class="level-left"><span class="level-item">2.12.1</span><span class="level-item">什么是Dockerfile</span></span></a></li><li><a class="level is-mobile" href="#Dockerfile解析过程"><span class="level-left"><span class="level-item">2.12.2</span><span class="level-item">Dockerfile解析过程</span></span></a></li><li><a class="level is-mobile" href="#Dockerfile的保留命令"><span class="level-left"><span class="level-item">2.12.3</span><span class="level-item">Dockerfile的保留命令</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#FROM-命令"><span class="level-left"><span class="level-item">2.12.3.1</span><span class="level-item">FROM 命令</span></span></a></li><li><a class="level is-mobile" href="#MAINTAINER-命令"><span class="level-left"><span class="level-item">2.12.3.2</span><span class="level-item">MAINTAINER  命令</span></span></a></li><li><a class="level is-mobile" href="#RUN-命令"><span class="level-left"><span class="level-item">2.12.3.3</span><span class="level-item">RUN 命令</span></span></a></li><li><a class="level is-mobile" href="#EXPOSE-命令"><span class="level-left"><span class="level-item">2.12.3.4</span><span class="level-item">EXPOSE 命令</span></span></a></li><li><a class="level is-mobile" href="#CMD-命令"><span class="level-left"><span class="level-item">2.12.3.5</span><span class="level-item">CMD 命令</span></span></a></li><li><a class="level is-mobile" href="#WORKDIR-命令"><span class="level-left"><span class="level-item">2.12.3.6</span><span class="level-item">WORKDIR 命令</span></span></a></li><li><a class="level is-mobile" href="#ENV-命令"><span class="level-left"><span class="level-item">2.12.3.7</span><span class="level-item">ENV 命令</span></span></a></li><li><a class="level is-mobile" href="#ADD-命令"><span class="level-left"><span class="level-item">2.12.3.8</span><span class="level-item">ADD 命令</span></span></a></li><li><a class="level is-mobile" href="#COPY-命令"><span class="level-left"><span class="level-item">2.12.3.9</span><span class="level-item">COPY 命令</span></span></a></li><li><a class="level is-mobile" href="#VOLUME-命令"><span class="level-left"><span class="level-item">2.12.3.10</span><span class="level-item">VOLUME 命令</span></span></a></li><li><a class="level is-mobile" href="#ENTRYPOINT命令"><span class="level-left"><span class="level-item">2.12.3.11</span><span class="level-item">ENTRYPOINT命令</span></span></a></li><li><a class="level is-mobile" href="#ENTRYPOINT命令-1"><span class="level-left"><span class="level-item">2.12.3.12</span><span class="level-item">ENTRYPOINT命令</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Dockerfile构建springboot项目部署"><span class="level-left"><span class="level-item">2.12.4</span><span class="level-item">Dockerfile构建springboot项目部署</span></span></a></li></ul></li><li><a class="level is-mobile" href="#高级网络配置"><span class="level-left"><span class="level-item">2.13</span><span class="level-item">高级网络配置</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#说明"><span class="level-left"><span class="level-item">2.13.1</span><span class="level-item">说明</span></span></a></li><li><a class="level is-mobile" href="#查看网络信息"><span class="level-left"><span class="level-item">2.13.2</span><span class="level-item">查看网络信息</span></span></a></li><li><a class="level is-mobile" href="#创建一个网桥"><span class="level-left"><span class="level-item">2.13.3</span><span class="level-item">创建一个网桥</span></span></a></li><li><a class="level is-mobile" href="#删除一个网桥"><span class="level-left"><span class="level-item">2.13.4</span><span class="level-item">删除一个网桥</span></span></a></li><li><a class="level is-mobile" href="#容器之前使用网络通信"><span class="level-left"><span class="level-item">2.13.5</span><span class="level-item">容器之前使用网络通信</span></span></a></li></ul></li><li><a class="level is-mobile" href="#高级数据卷配置"><span class="level-left"><span class="level-item">2.14</span><span class="level-item">高级数据卷配置</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#说明-1"><span class="level-left"><span class="level-item">2.14.1</span><span class="level-item">说明</span></span></a></li><li><a class="level is-mobile" href="#创建数据卷"><span class="level-left"><span class="level-item">2.14.2</span><span class="level-item">创建数据卷</span></span></a></li><li><a class="level is-mobile" href="#查看数据卷"><span class="level-left"><span class="level-item">2.14.3</span><span class="level-item">查看数据卷</span></span></a></li><li><a class="level is-mobile" href="#挂载数据卷"><span class="level-left"><span class="level-item">2.14.4</span><span class="level-item">挂载数据卷</span></span></a></li><li><a class="level is-mobile" href="#删除数据卷"><span class="level-left"><span class="level-item">2.14.5</span><span class="level-item">删除数据卷</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Docker-Compose"><span class="level-left"><span class="level-item">2.15</span><span class="level-item">Docker Compose</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#简介"><span class="level-left"><span class="level-item">2.15.1</span><span class="level-item">简介</span></span></a></li><li><a class="level is-mobile" href="#安装与卸载"><span class="level-left"><span class="level-item">2.15.2</span><span class="level-item">安装与卸载</span></span></a></li><li><a class="level is-mobile" href="#docker-compose使用"><span class="level-left"><span class="level-item">2.15.3</span><span class="level-item">docker compose使用</span></span></a></li><li><a class="level is-mobile" href="#docker-compose-模板文件"><span class="level-left"><span class="level-item">2.15.4</span><span class="level-item">docker-compose 模板文件</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#build"><span class="level-left"><span class="level-item">2.15.4.1</span><span class="level-item">build</span></span></a></li><li><a class="level is-mobile" href="#command"><span class="level-left"><span class="level-item">2.15.4.2</span><span class="level-item">command</span></span></a></li><li><a class="level is-mobile" href="#container-name"><span class="level-left"><span class="level-item">2.15.4.3</span><span class="level-item">container_name</span></span></a></li><li><a class="level is-mobile" href="#depends-on"><span class="level-left"><span class="level-item">2.15.4.4</span><span class="level-item">depends_on</span></span></a></li><li><a class="level is-mobile" href="#env-file"><span class="level-left"><span class="level-item">2.15.4.5</span><span class="level-item">env_file</span></span></a></li><li><a class="level is-mobile" href="#environment"><span class="level-left"><span class="level-item">2.15.4.6</span><span class="level-item">environment</span></span></a></li><li><a class="level is-mobile" href="#healthcheck"><span class="level-left"><span class="level-item">2.15.4.7</span><span class="level-item">healthcheck</span></span></a></li><li><a class="level is-mobile" href="#image"><span class="level-left"><span class="level-item">2.15.4.8</span><span class="level-item">image</span></span></a></li><li><a class="level is-mobile" href="#networks"><span class="level-left"><span class="level-item">2.15.4.9</span><span class="level-item">networks</span></span></a></li><li><a class="level is-mobile" href="#ports"><span class="level-left"><span class="level-item">2.15.4.10</span><span class="level-item">ports</span></span></a></li><li><a class="level is-mobile" href="#sysctls"><span class="level-left"><span class="level-item">2.15.4.11</span><span class="level-item">sysctls</span></span></a></li><li><a class="level is-mobile" href="#ulimits"><span class="level-left"><span class="level-item">2.15.4.12</span><span class="level-item">ulimits</span></span></a></li><li><a class="level is-mobile" href="#volumes"><span class="level-left"><span class="level-item">2.15.4.13</span><span class="level-item">volumes</span></span></a></li></ul></li><li><a class="level is-mobile" href="#docker-compose-常用命令"><span class="level-left"><span class="level-item">2.15.5</span><span class="level-item">docker-compose 常用命令</span></span></a></li></ul></li><li><a class="level is-mobile" href="#可视化管理工具"><span class="level-left"><span class="level-item">2.16</span><span class="level-item">可视化管理工具</span></span></a><ul class="menu-list"><ul class="menu-list"><li><a class="level is-mobile" href="#安装Portainer"><span class="level-left"><span class="level-item">2.16.1.1</span><span class="level-item">安装Portainer</span></span></a></li><li><a class="level is-mobile" href="#登录和使用Portainer"><span class="level-left"><span class="level-item">2.16.1.2</span><span class="level-item">登录和使用Portainer</span></span></a></li><li><a class="level is-mobile" href="#使用过程…"><span class="level-left"><span class="level-item">2.16.1.3</span><span class="level-item">使用过程…</span></span></a></li></ul></ul></li></ul></li><li><a class="level is-mobile" href="#Docker-核心原理"><span class="level-left"><span class="level-item">3</span><span class="level-item">Docker 核心原理</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/golang/"><span class="tag">golang</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/timeline/"><span class="tag">timeline</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><span class="tag">并发编程</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%93%E5%AD%98/"><span class="tag">缓存</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"><span class="tag">分布式</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%A2%86%E5%9F%9F%E7%AE%97%E6%B3%95/"><span class="tag">领域算法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"><span class="tag">知识体系</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/goland%E6%8A%80%E5%B7%A7/"><span class="tag">goland技巧</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"><span class="tag">高并发</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Myblog/"><span class="tag">Myblog</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mysql/"><span class="tag">mysql</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nacos/"><span class="tag">nacos</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="tag">操作系统</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-01-18T07:26:50.000Z">2024-01-18</time></p><p class="title"><a href="/post/dive-distributed-transaction-solution-zoglxs.html">种分布式事务解决方案</a></p><p class="categories"><a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E3%80%81%E6%9E%B6%E6%9E%84/">分布式、微服务、架构</a> / <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E3%80%81%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-01-08T05:47:25.000Z">2024-01-08</time></p><p class="title"><a href="/post/three-core-themes-of-the-operating-system-z2lftgm.html">操作系统三大核心主题</a></p><p class="categories"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82/">计算机底层</a> / <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-01-03T08:09:58.000Z">2024-01-03</time></p><p class="title"><a href="/post/distributed-cache-global-cognition-11klor.html">分布式缓存全局认知</a></p><p class="categories"><a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E3%80%81%E6%9E%B6%E6%9E%84/">分布式、微服务、架构</a> / <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E3%80%81%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-28T02:40:09.000Z">2023-12-28</time></p><p class="title"><a href="/post/using-godebug-more-intuitively-to-understand-the-go-scheduling-process-z1bawyb.html">利用GODEBUG更直观地理解 Go 调度过程</a></p><p class="categories"><a href="/categories/Golang/">Golang</a> / <a href="/categories/Golang/%E6%A0%B8%E5%BF%83%E5%BA%95%E5%B1%82/">核心底层</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-26T05:42:26.000Z">2023-12-26</time></p><p class="title"><a href="/post/go-parallel-programming-channel-z13snhx.html">Go并发编程 | Channel</a></p><p class="categories"><a href="/categories/Golang/">Golang</a> / <a href="/categories/Golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></p></div></article></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="林庭晚阖" height="28"></a><p class="is-size-7"><span>&copy; 2024 luommy</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/mhchem.min.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><!-- hexo injector body_end start -->
  <script type="text/javascript" src="/custom/custom.js"></script>
<!-- hexo injector body_end end --></body></html>