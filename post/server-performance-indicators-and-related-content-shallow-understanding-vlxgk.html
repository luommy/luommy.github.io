<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>服务器性能指标相关内容 - 林庭晚阖</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="林庭晚阖"><meta name="msapplication-TileImage" content="/img/kafka.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="林庭晚阖"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="QPS、TPS、RT、阿姆达尔定律等相关的理解"><meta property="og:type" content="blog"><meta property="og:title" content="服务器性能指标相关内容"><meta property="og:url" content="https://luommy.github.io/post/server-performance-indicators-and-related-content-shallow-understanding-vlxgk.html"><meta property="og:site_name" content="林庭晚阖"><meta property="og:description" content="QPS、TPS、RT、阿姆达尔定律等相关的理解"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311231501393.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311221621844.png"><meta property="article:published_time" content="2023-11-22T08:21:08.000Z"><meta property="article:modified_time" content="2023-11-23T07:01:08.000Z"><meta property="article:author" content="luommy"><meta property="article:tag" content="软件架构,服务端开发,Go,微服务,数据结构与算法,底层"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311231501393.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://luommy.github.io/post/server-performance-indicators-and-related-content-shallow-understanding-vlxgk.html"},"headline":"服务器性能指标相关内容","image":["https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311231501393.png","https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311221621844.png"],"datePublished":"2023-11-22T08:21:08.000Z","dateModified":"2023-11-23T07:01:08.000Z","author":{"@type":"Person","name":"luommy"},"publisher":{"@type":"Organization","name":"林庭晚阖","logo":{"@type":"ImageObject","url":"https://luommy.github.io/img/logo.svg"}},"description":"QPS、TPS、RT、阿姆达尔定律等相关的理解"}</script><link rel="canonical" href="https://luommy.github.io/post/server-performance-indicators-and-related-content-shallow-understanding-vlxgk.html"><link rel="icon" href="/img/kafka.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/vs.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><script>var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?ecf13ffee9f4083d9a74b337b541f90b";
            var s = document.getElementsByTagName("script")[0];
            s.parentNode.insertBefore(hm, s);
        })();</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script>
  <link rel="stylesheet" href="/custom/custom.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="林庭晚阖" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">文章</a><a class="navbar-item" href="/tags/timeline">心情</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/links.html">友链</a><a class="navbar-item" href="/guestbook.html">留言</a><a class="navbar-item" href="/about.html">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="发邮件" href="mailto:jdonglecool@163.com"><i class="fab fa-regular fa-envelope"></i></a><a class="navbar-item" target="_blank" rel="noopener" title="GitHub" href="https://github.com/luommy"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2023-11-22T08:21:08.000Z" title="11/22/2023, 8:21:08 AM">2023-11-22</time>发表</span><span class="level-item"><time dateTime="2023-11-23T07:01:08.000Z" title="11/23/2023, 7:01:08 AM">2023-11-23</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E3%80%81%E6%9E%B6%E6%9E%84/">分布式、微服务、架构</a><span> / </span><a class="link-muted" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E3%80%81%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84/">架构</a></span><span class="level-item">36 分钟读完 (大约5456个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">服务器性能指标相关内容</h1><div class="content"><h1 id="服务器性能指标相关内容"><a href="#服务器性能指标相关内容" class="headerlink" title="服务器性能指标相关内容"></a>服务器性能指标相关内容</h1><blockquote>
<p>以前不了解这方面，常听说什么12306、双十一淘宝、天猫的并发支撑的某某性能数据都感觉很酷的样子…..实际情况就是：我知道确实很强，但这些数据性能反应怎么个水平，强到什么水平，完全没有概念，比如可以并发支持用户同时的千万级请求、上亿的同时请求，强到什么概念，凭什么可以这么强，是完全无法想象的…..就比如我先现在八块腹肌、单手五十个俯卧撑，外行感觉很强，但是只有我自己知道付出了多少努力(其实没有多少努力全看天赋[dog])……</p>
<p>其实打算把这一部分划分到高并发区域，但是这都是一些基础的概念和微不足道的理解，还是划分到架构板块了。</p>
</blockquote>
<p>11.21 新的理解：我的评价是高并发不及高可用！可高用是真的太难了[dog]</p>
<p>一些常见名词、概念：</p>
<ul>
<li><p><strong>峰值时间：每天80%的访问集中在20%的时间里，这20%时间即峰值时间</strong></p>
</li>
<li><p><strong>并发：一段时间访问的大量用户的请求（并发是最能体现你的程序和机器的性能。）</strong></p>
</li>
<li><p><strong>并行：同一时刻的大量用户的请求(并发和并行很像，但是维度不同)</strong></p>
</li>
<li><p>QPS（每秒查询率）：对应fetches&#x2F;sec，即每秒的响应请求数，也即是最大吞吐能力。</p>
<p>QPS &#x3D; 并发量 &#x2F; 平均响应时间</p>
<p>并发量 &#x3D; QPS * 平均响应时间</p>
</li>
<li><p>峰值估算公式：( 总PV数 * 80% ) &#x2F; ( 每天秒数 * 20% ) &#x3D; 峰值时间每秒请求数(QPS)</p>
</li>
<li><p>机器：峰值时间每秒QPS &#x2F; 单台机器的QPS &#x3D; 需要的机器数量</p>
</li>
<li><p><strong>阿姆达尔定律</strong>：不可并行部分的比率才是决定着是否能成倍增长效率的关键，CPU核心数的提升不一定能够提升QPS</p>
</li>
</ul>
<h1 id="QPS："><a href="#QPS：" class="headerlink" title="QPS："></a>QPS：</h1><p>QPS（Queries-per-second）是每秒钟查询率，是<strong>一台服务器</strong>每秒能够相应的查询次数，是对一个特定的查询服务器<strong>在规定时间内</strong>所处理流量多少的衡量标准,  即每秒的响应请求数，也即是最大吞吐能力。</p>
<p>对应fetches&#x2F;sec，即每秒的响应请求数&#x2F;每秒查询率 </p>
<p>QPS即每秒处理事务数，包括了用户请求服务器、服务器自己的内部处理、服务器返回给用户。这三个过程，每秒能够完成N个这三个过程，TPS也就是N；</p>
<p>Qps基本类似于Tps，但是不同的是，对于一个页面的一次访问，形成一个Tps；</p>
<p>但一次页面请求，可能产生多次对服务器的请求，服务器对这些请求，就可计入“QPS”之中。理解上来看QPS可能颗粒度更细一点。</p>
<h1 id="TPS"><a href="#TPS" class="headerlink" title="TPS"></a>TPS</h1><p>TPS：Transactions Per Second（每秒传输的事物处理个数），即服务器每秒处理的事务数。</p>
<p>即每秒处理事务数，每个事务包括了如下3个过程：</p>
<p>　　a.用户请求服务器</p>
<p>　　b.服务器自己的内部处理（包含应用服务器、数据库服务器等）</p>
<p>　　c.服务器返回给用户</p>
<p>　　如果每秒能够完成N个这三个过程，tps就是N；</p>
<p>一般的，评价系统性能均以每秒钟完成的技术交易的数量来衡量。<u>系统整体处理能力取决于处理能力最低模块的TPS值。</u>这一点有一点深入的体会，金融交易所涉及的金融交易，一般使用的都是TPS来衡量。比如交易清仓高峰时间、订单峰值之类的可以联想一下。</p>
<h1 id="RT"><a href="#RT" class="headerlink" title="RT"></a>RT</h1><p>响应时间即RT，处理一次请求所需要的平均处理时间。对于RT，客户端和服务端是大不相同的，因为请求从客户端到服务端，需要经过<em>广域网</em>，所以<strong>客户端RT往往远大于服务端RT</strong>，同时客户端的RT往往决定着用户的真实体验，<u>服务端RT往往是评估我们系统好坏的一个关键因素</u>。这一点说白了我们能够控制的只有服务器、后端的这一部分链路，涉及到物理、底层基础设施建设的我想很难把控，因为要考虑的因素太多，猜测涉及大部门之间的跨越。</p>
<h1 id="最佳线程数的困扰"><a href="#最佳线程数的困扰" class="headerlink" title="最佳线程数的困扰"></a>最佳线程数的困扰</h1><p>在开发过程中，我们一定面临过很多的线程数量的配置问题，这种问题往往让人摸不到头脑，往往都是拍脑袋给出一个线程池的数量，但这可能恰恰是不靠谱的，过小的话会导致请求RT极具增加，过大也一样RT也会升高。所以对于最佳线程数的评估往往比较麻烦。</p>
<p><em>这一部分有一说一确实没有比较好的实践思路….后续可能会了解下，但有固定的思路，但go中又很特殊，是goroutine，猜想应用基准测试来尝试，慢慢试；或者计算，但是计算好像是线程层面的，比如Java中经常喜欢计算求得最佳线程数</em></p>
<h1 id="QPS和RT的关系"><a href="#QPS和RT的关系" class="headerlink" title="QPS和RT的关系"></a>QPS和RT的关系</h1><h2 id="单线程场景："><a href="#单线程场景：" class="headerlink" title="单线程场景："></a>单线程场景：</h2><p>假设我们的服务端只有一个线程，那么所有的请求都是串行执行，我们可以很简单的算出系统的QPS，也就是：<strong>QPS &#x3D; 1000ms&#x2F;RT</strong>。假设一个RT过程中CPU计算的时间为49ms，CPU Wait Time 为200ms，那么QPS就为1000&#x2F;（49+200） &#x3D; 4.01。</p>
<h2 id="多线程场景"><a href="#多线程场景" class="headerlink" title="多线程场景"></a>多线程场景</h2><p>我们接下来把服务端的线程数提升到2，那么整个系统的QPS则为：2 *（1000&#x2F;(49+200)）&#x3D;8.02。可见QPS随着线程的增加而线性增长，那QPS上不去就加线程呗，听起来很有道理，公式也说得通，但是往往现实并非如此，后面会聊这个问题。</p>
<h1 id="最佳线程数？"><a href="#最佳线程数？" class="headerlink" title="最佳线程数？"></a>最佳线程数？</h1><p>从上面单线程场景来看，CPU Wait time为200ms,你可以理解为CPU这段时间什么都没做，是空闲的，显然我们没把CPU利用起来，这时候我们需要启多个线程去响应请求，把这部分利用起来，那么启动多少个线程呢？我们可以估算一下 空闲时间200ms，我们要把这部分时间转换为CPU Time,那么就是(200+49)&#x2F;49 &#x3D; 5.08个，不考虑上下文切换的话，约等于5个线程。同时还要考虑CPU的核心数和利用率问题，那么我们得到了最佳线程数计算的公式：<br> <strong>(（CPU Time + CPU Wait Time）&#x2F; CPU Time) * coreSize * cupRatio</strong></p>
<h1 id="最大QPS？"><a href="#最大QPS？" class="headerlink" title="最大QPS？"></a>最大QPS？</h1><p>得到了最大的线程数和QPS的计算方式：</p>
<p><strong>QPS &#x3D; Thread num * 单线程QPS &#x3D; （CPU Time + CPU Wait Time）&#x2F;CPU Time * coreSize * CupRatio * (1000ms&#x2F;(CPU Time + CPU Wait Time)) &#x3D; (1000ms&#x2F; CPU Time) * coreSize * cpuRatio</strong></p>
<p>所以决定一个系统最大的QPS的因素是CPU Time、CoreSize和CPU利用率。看似增加CPU核数（或者说线程数）可以成倍的增加系统QPS，但实际上增加线程数的同时也增加了很大的系统负荷，更多的上下文切换，QPS和最大的QPS是有偏差的。</p>
<h1 id="CPU-Time-CPU-Wait-Time-CPU-利用率"><a href="#CPU-Time-CPU-Wait-Time-CPU-利用率" class="headerlink" title="CPU Time &amp; CPU Wait Time &amp; CPU 利用率"></a>CPU Time &amp; CPU Wait Time &amp; CPU 利用率</h1><p><strong>CPU Time</strong>：就是一次请求中，实际用到计算资源。CPU Time的消耗是全流程的，涉及到请求到应用服务器，再从应用服务器返回的全过程。实际上这取决于你的计算的复杂度。<br><strong>CPU Wait Time</strong>：是一次请求过程中对于IO的操作，CPU这段时间可以理解为空闲的，那么此时要尽量利用这些空闲时间，也就是增加线程数。<br><strong>CPU 利用率</strong>：是业务系统利用到CPU的比率，因为往往一个系统上会有一些其他的线程，这些线程会和CPU竞争计算资源，那么此时留给业务的计算资源比例就会下降，典型的像，GC线程的GC过程、锁的竞争过程都是消耗CPU的过程。甚至一些IO的瓶颈，也会导致CPU利用率下降(CPU都在Wait IO，利用率当然不高)。</p>
<h1 id="增加CPU核数是否能对QPS得到提升？"><a href="#增加CPU核数是否能对QPS得到提升？" class="headerlink" title="增加CPU核数是否能对QPS得到提升？"></a>增加CPU核数是否能对QPS得到提升？</h1><p><strong>首先答案是不一定</strong></p>
<p>从上面的公式我们可以看出，假设CPU Time和CPU 利用率不变，增加CPU的核数能使QPS呈线性增长。但是很遗憾，现实中不是这样的…首先先看一下<strong>阿姆达尔定律</strong>：<br>阿姆达尔定律给出了任务在固定负载的情况下，随着系统资源的提升，执行速度的理论上限。以计算机科学家Gene Amdahl命名。</p>
<p>​​​<img src="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311231501393.png" alt="image">​​​</p>
<p>其中<br>Slatency: 整个任务的提速比。<br>s: 部分任务得益于系统资源升级带来的提速比。<br>p: 这部分任务执行时间占整个任务执行时间的百分比（系统资源提升前）。</p>
<p>从上可以得到：</p>
<p>​​<img src="https://cdn.jsdelivr.net/gh/luommy/myblogimg@img/myblog/202311221621844.png" alt="image">​​</p>
<p>以上公式说明了通过资源升级来给任务加速的加速比上限，而且和提速的幅度无关，理论加速比总是受限于不能加速的任务的比例。</p>
<p>阿姆达尔的定律常用于并行计算中，用来估计多处理器情况下的理论加速比。例如，如果有个程序在单核下需要执行20个小时，并且不能被并行处理的部分占1个小时的执行时间，剩余的19个小时(p&#x3D;0,95)的任务可以并行化，那么不管有多少核心来并行处理这个程序，最小执行时间不可能小于一个小时。由此得到，理论加速比的上限是20倍（1&#x2F;(1-p) &#x3D; 20）。因此，并行计算只和少数的核心和极度可并行化的程序相关。</p>
<p>同样，对于1000ms&#x2F;(CPU Time) * coreSize * cpuRatio我们不断的增加CoreSize或者说线程数的时候。我们的请求变多了，随之而来的就是大量的上下文切换（go中的协程不涉及上下文切换） <strong>、大量的GC、大量的锁征用</strong>，这些会增加不可并行部分的总时间，也会大大的增加CPU Time。假设我们的串行部分不变的话，增大核数，CPU不能得到充分的利用，利用率也会降低。所以，对于阿姆达尔定律而言，不可并行部分的比率才是决定着是否能成倍增长效率的关键。也就是说最佳线程数也好，最大QPS也好，增加内核数量不一定能是系统指标有成倍的增长。更关键的是能改变自己的架构，减小串行的比率，让CPU更充分的利用，达到资源的最大利用率。</p>
<h1 id="如何寻求最佳线程数和最大QPS"><a href="#如何寻求最佳线程数和最大QPS" class="headerlink" title="如何寻求最佳线程数和最大QPS"></a>如何寻求最佳线程数和最大QPS</h1><p>通过上面一些例子，我们发现当线程数增加的时候，线程的上下文切换会增加，GC Time会增加。这也就导致CPU time 增加，QPS减小，RT也会随着增大。这显然不是我们希望的，我们希望的是在核数一定的情况下找到某个点，使系统的QPS最大，RT相对较小。所以我们需要不断的压测，调整线程池，找到这个QPS的峰值，并且使CPU的利用率达到100%,这样才是系统的最大QPS和最佳线程数。</p>
<h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。概括来说就是: 当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。<strong>Linux 相比与其他操作系统(包括其他类 Unix 系统)有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</strong></p>
<p>类比于实现世界中的人类通过合作做某件事情，我们可以肯定的一点是线程池大小设置过大或者过小都会有问题，合适的才是最好。</p>
<p>如果我们设置的线程池数量太小的话，如果同一时间有大量任务&#x2F;请求需要处理，可能会导致大量的请求任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务&#x2F;请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM。这样很明显是有问题的，CPU 根本没有得到充分利用。</p>
<p>如果我们设置线程数量太大，大量线程可能会同时在争取 CPU 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率</p>
<h2 id="CPU密集任务与I-O密集任务"><a href="#CPU密集任务与I-O密集任务" class="headerlink" title="CPU密集任务与I&#x2F;O密集任务"></a>CPU密集任务与I&#x2F;O密集任务</h2><p>有一个简单并且适用面比较广的公式:</p>
<p>CPU 密集型任务(N+1): 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N (CPU 核心数)+1.比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用CPU 的空闲时间。</p>
<p>I&#x2F;O 密集型任务(2N): 这种任务应用起来，系统会用大部分的时间来处理 &#x2F;0 交互，而线程在处理 &#x2F;O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。</p>
<p>如何判断是 CPU 密集任务还是Io 密集任务?</p>
<p>CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。但凡涉及<em>网络读取，文件读取</em>这类都是 I&#x2F;O 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待I&#x2F;O操作完成的时间来说很少，大部分时间都花在了等待 I&#x2F;O 操作完成上.</p>
<p>线程数更严谨的计算的方法应该是:</p>
<p>最佳线程数 &#x3D;  (CPU 核心数)* (1+MT(线程等待时间)&#x2F;ST (线程计算时间))</p>
<p>公示也只是参考，具体还是要根据项目实际线上运行情况来动态调整。</p>
<h2 id="PV"><a href="#PV" class="headerlink" title="PV"></a>PV</h2><p>PV（Page View）：页面访问量，即页面浏览量或点击量，用户每次刷新即被计算一次。可以统计服务一天的访问日志得到。</p>
<h2 id="UV"><a href="#UV" class="headerlink" title="UV"></a>UV</h2><p>UV（Unique Visitor）：独立访客，统计1天内访问某站点的用户数。可以统计服务一天的访问日志并根据用户的唯一标识去重得到。响应时间（RT）：响应时间是指系统对请求作出响应的时间，一般取平均响应时间。可以通过Nginx、Apache之类的Web Server得到。</p>
<h2 id="DAU"><a href="#DAU" class="headerlink" title="DAU"></a>DAU</h2><p>DAU(Daily Active User)，日活跃用户数量。常用于反映网站、互联网应用或网络游戏的运营情况。DAU通常统计一日（统计日）之内，登录或使用了某个产品的用户数（去除重复登录的用户），与UV概念相似</p>
<h2 id="MAU"><a href="#MAU" class="headerlink" title="MAU"></a>MAU</h2><p>MAU(Month Active User)：月活跃用户数量，指网站、app等去重后的月活跃用户数量</p>
<h2 id="系统吞吐量评估"><a href="#系统吞吐量评估" class="headerlink" title="系统吞吐量评估"></a>系统吞吐量评估</h2><p>我们在做系统设计的时候就需要考虑CPU运算，IO，外部系统响应因素造成的影响以及对系统性能的初步预估。<br>而通常情况下，我们面对需求，我们评估出来的出来QPS，并发数之外，还有另外一个维度：日pv。</p>
<p>通过观察系统的访问日志发现，在用户量很大的情况下，各个时间周期内的同一时间段的访问流量几乎一样。比如工作日的每天早上。只要能拿到日流量图和QPS我们就可以推算日流量。</p>
<p>通常的技术方法：</p>
<p>1、找出系统的最高TPS和日PV，这两个要素有相对比较稳定的关系（除了放假、季节性因素影响之外）。</p>
<p>2、通过压力测试或者经验预估，得出最高TPS，然后跟进1结果的关系，计算出系统最高的日吞吐量。B2B中文和淘宝面对的客户群不一样，这两个客户群的网络行为不应用，他们之间的TPS和PV关系比例也不一样。</p>
<h2 id="软件性能测试的基本概念和计算公式"><a href="#软件性能测试的基本概念和计算公式" class="headerlink" title="软件性能测试的基本概念和计算公式"></a>软件性能测试的基本概念和计算公式</h2><p>软件做性能测试时需要关注哪些性能呢？</p>
<p>首先，开发软件的目的是为了让用户使用，我们先站在用户的角度分析一下，用户需要关注哪些性能。</p>
<p>对于用户来说，当点击一个按钮、链接或发出一条指令开始，到系统把结果已用户感知的形式展现出来为止，这个过程所消耗的时间是用户对这个软件性能的直观印 象。也就是我们所说的响应时间，当相应时间较小时，用户体验是很好的，当然用户体验的响应时间包括个人主观因素和客观响应时间，在设计软件时，我们就需要考虑到如何更好地结合这两部分达到用户最佳的体验。如：<strong>用户在大数据量查询时，我们可以将先提取出来的数据展示给用户，在用户看的过程中继续进行数据检索，这时用户并不知道我们后台在做什么。</strong></p>
<p>用户关注的是用户操作的相应时间。</p>
<p>其次，我们站在管理员的角度考虑需要关注的性能点。</p>
<p>1、 响应时间<br>2、 服务器资源使用情况是否合理<br>3、 应用服务器和数据库资源使用是否合理<br>4、 系统能否实现扩展<br>5、 系统最多支持多少用户访问、系统最大业务处理量是多少<br>6、 系统性能可能存在的瓶颈在哪里<br>7、 更换那些设备可以提高性能<br>8、 系统能否支持7×24小时的业务访问</p>
<p>再次，站在开发（设计）人员角度去考虑。</p>
<p>1、 架构设计是否合理<br>2、 数据库设计是否合理<br>3、 代码是否存在性能方面的问题<br>4、 系统中是否有不合理的内存使用方式<br>5、 系统中是否存在不合理的线程同步方式<br>6、 系统中是否存在不合理的资源竞争  </p>
<p>‍</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>服务器性能指标相关内容</p><p><a href="https://luommy.github.io/post/server-performance-indicators-and-related-content-shallow-understanding-vlxgk.html">https://luommy.github.io/post/server-performance-indicators-and-related-content-shallow-understanding-vlxgk.html</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>luommy</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2023-11-22</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-11-23</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/" alt="微信"></span></a><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/" alt="支付宝"></span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="afdian"><span class="icon is-small"><i class="fas fa-charging-station"></i></span><span>爱发电</span></a><a class="button donate" href="/" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>送我杯咖啡</span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/post/global-understanding-the-evolution-of-microservices-architecture-eww7f.html"><i class="level-item fas fa-chevron-left"></i><span class="level-item">全局理解：微服务架构演进</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/post/golang-test-related-mbnma.html"><span class="level-item">Golang测试</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div class="content" id="waline-thread"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@waline/client@2.6.3/dist/waline.css"><script src="https://cdn.jsdelivr.net/npm/@waline/client@2.6.3/dist/waline.js"></script><script>Waline.init({
            el: '#waline-thread',
            serverURL: "https://myblog-vercel.vercel.app/",
            path: window.location.pathname,
            lang: "zh-CN",
            
            emoji: ["https://cdn.jsdelivr.net/gh/walinejs/emojis/weibo"],
            dark: "auto",
            meta: ["nick","mail","link"],
            requiredMeta: [],
            login: "disable",
            
            pageSize: 10,
            imageUploader: false,
            highlighter: false,
            texRenderer: false,
            search: false,
            pageview: false,
            comment: false,
            copyright: true,
        });</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#服务器性能指标相关内容"><span class="level-left"><span class="level-item">1</span><span class="level-item">服务器性能指标相关内容</span></span></a></li><li><a class="level is-mobile" href="#QPS："><span class="level-left"><span class="level-item">2</span><span class="level-item">QPS：</span></span></a></li><li><a class="level is-mobile" href="#TPS"><span class="level-left"><span class="level-item">3</span><span class="level-item">TPS</span></span></a></li><li><a class="level is-mobile" href="#RT"><span class="level-left"><span class="level-item">4</span><span class="level-item">RT</span></span></a></li><li><a class="level is-mobile" href="#最佳线程数的困扰"><span class="level-left"><span class="level-item">5</span><span class="level-item">最佳线程数的困扰</span></span></a></li><li><a class="level is-mobile" href="#QPS和RT的关系"><span class="level-left"><span class="level-item">6</span><span class="level-item">QPS和RT的关系</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#单线程场景："><span class="level-left"><span class="level-item">6.1</span><span class="level-item">单线程场景：</span></span></a></li><li><a class="level is-mobile" href="#多线程场景"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">多线程场景</span></span></a></li></ul></li><li><a class="level is-mobile" href="#最佳线程数？"><span class="level-left"><span class="level-item">7</span><span class="level-item">最佳线程数？</span></span></a></li><li><a class="level is-mobile" href="#最大QPS？"><span class="level-left"><span class="level-item">8</span><span class="level-item">最大QPS？</span></span></a></li><li><a class="level is-mobile" href="#CPU-Time-CPU-Wait-Time-CPU-利用率"><span class="level-left"><span class="level-item">9</span><span class="level-item">CPU Time &amp; CPU Wait Time &amp; CPU 利用率</span></span></a></li><li><a class="level is-mobile" href="#增加CPU核数是否能对QPS得到提升？"><span class="level-left"><span class="level-item">10</span><span class="level-item">增加CPU核数是否能对QPS得到提升？</span></span></a></li><li><a class="level is-mobile" href="#如何寻求最佳线程数和最大QPS"><span class="level-left"><span class="level-item">11</span><span class="level-item">如何寻求最佳线程数和最大QPS</span></span></a></li><li><a class="level is-mobile" href="#补充"><span class="level-left"><span class="level-item">12</span><span class="level-item">补充</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#上下文切换"><span class="level-left"><span class="level-item">12.1</span><span class="level-item">上下文切换</span></span></a></li><li><a class="level is-mobile" href="#CPU密集任务与I-O密集任务"><span class="level-left"><span class="level-item">12.2</span><span class="level-item">CPU密集任务与I/O密集任务</span></span></a></li><li><a class="level is-mobile" href="#PV"><span class="level-left"><span class="level-item">12.3</span><span class="level-item">PV</span></span></a></li><li><a class="level is-mobile" href="#UV"><span class="level-left"><span class="level-item">12.4</span><span class="level-item">UV</span></span></a></li><li><a class="level is-mobile" href="#DAU"><span class="level-left"><span class="level-item">12.5</span><span class="level-item">DAU</span></span></a></li><li><a class="level is-mobile" href="#MAU"><span class="level-left"><span class="level-item">12.6</span><span class="level-item">MAU</span></span></a></li><li><a class="level is-mobile" href="#系统吞吐量评估"><span class="level-left"><span class="level-item">12.7</span><span class="level-item">系统吞吐量评估</span></span></a></li><li><a class="level is-mobile" href="#软件性能测试的基本概念和计算公式"><span class="level-left"><span class="level-item">12.8</span><span class="level-item">软件性能测试的基本概念和计算公式</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/golang/"><span class="tag">golang</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/timeline/"><span class="tag">timeline</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><span class="tag">并发编程</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%93%E5%AD%98/"><span class="tag">缓存</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"><span class="tag">分布式</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%A2%86%E5%9F%9F%E7%AE%97%E6%B3%95/"><span class="tag">领域算法</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/"><span class="tag">知识体系</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/goland%E6%8A%80%E5%B7%A7/"><span class="tag">goland技巧</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"><span class="tag">高并发</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Myblog/"><span class="tag">Myblog</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mysql/"><span class="tag">mysql</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nacos/"><span class="tag">nacos</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="tag">操作系统</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-01-18T07:26:50.000Z">2024-01-18</time></p><p class="title"><a href="/post/dive-distributed-transaction-solution-zoglxs.html">种分布式事务解决方案</a></p><p class="categories"><a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E3%80%81%E6%9E%B6%E6%9E%84/">分布式、微服务、架构</a> / <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E3%80%81%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-01-08T05:47:25.000Z">2024-01-08</time></p><p class="title"><a href="/post/three-core-themes-of-the-operating-system-z2lftgm.html">操作系统三大核心主题</a></p><p class="categories"><a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82/">计算机底层</a> / <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%BA%95%E5%B1%82/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-01-03T08:09:58.000Z">2024-01-03</time></p><p class="title"><a href="/post/distributed-cache-global-cognition-11klor.html">分布式缓存全局认知</a></p><p class="categories"><a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E3%80%81%E6%9E%B6%E6%9E%84/">分布式、微服务、架构</a> / <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E3%80%81%E5%BE%AE%E6%9C%8D%E5%8A%A1%E3%80%81%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-28T02:40:09.000Z">2023-12-28</time></p><p class="title"><a href="/post/using-godebug-more-intuitively-to-understand-the-go-scheduling-process-z1bawyb.html">利用GODEBUG更直观地理解 Go 调度过程</a></p><p class="categories"><a href="/categories/Golang/">Golang</a> / <a href="/categories/Golang/%E6%A0%B8%E5%BF%83%E5%BA%95%E5%B1%82/">核心底层</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2023-12-26T05:42:26.000Z">2023-12-26</time></p><p class="title"><a href="/post/go-parallel-programming-channel-z13snhx.html">Go并发编程 | Channel</a></p><p class="categories"><a href="/categories/Golang/">Golang</a> / <a href="/categories/Golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a></p></div></article></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="林庭晚阖" height="28"></a><p class="is-size-7"><span>&copy; 2024 luommy</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/mhchem.min.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><!-- hexo injector body_end start -->
  <script type="text/javascript" src="/custom/custom.js"></script>
<!-- hexo injector body_end end --></body></html>